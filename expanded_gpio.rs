pub mod gpio {
    use proto_hal::macros::block;
    mod gpioa {
        pub mod moder {
            pub mod mode0 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode1 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode0::OFFSET + super::mode0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode0::OFFSET + super::mode0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode2 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode1::OFFSET + super::mode1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode1::OFFSET + super::mode1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode3 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode2::OFFSET + super::mode2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode2::OFFSET + super::mode2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode4 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode3::OFFSET + super::mode3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode3::OFFSET + super::mode3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode5 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode4::OFFSET + super::mode4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode4::OFFSET + super::mode4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode6 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode5::OFFSET + super::mode5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode5::OFFSET + super::mode5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode7 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode6::OFFSET + super::mode6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode6::OFFSET + super::mode6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode8 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode7::OFFSET + super::mode7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode7::OFFSET + super::mode7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode9 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode8::OFFSET + super::mode8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode8::OFFSET + super::mode8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode10 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode9::OFFSET + super::mode9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode9::OFFSET + super::mode9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode11 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode10::OFFSET + super::mode10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode10::OFFSET + super::mode10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode12 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode11::OFFSET + super::mode11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode11::OFFSET + super::mode11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode13 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode12::OFFSET + super::mode12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Alternate;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode12::OFFSET + super::mode12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode14 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode13::OFFSET + super::mode13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Alternate;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode13::OFFSET + super::mode13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode15 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode14::OFFSET + super::mode14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Alternate;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode14::OFFSET + super::mode14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = 0 as u32;
            pub struct Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: Mode0,
                pub mode1: Mode1,
                pub mode2: Mode2,
                pub mode3: Mode3,
                pub mode4: Mode4,
                pub mode5: Mode5,
                pub mode6: Mode6,
                pub mode7: Mode7,
                pub mode8: Mode8,
                pub mode9: Mode9,
                pub mode10: Mode10,
                pub mode11: Mode11,
                pub mode12: Mode12,
                pub mode13: Mode13,
                pub mode14: Mode14,
                pub mode15: Mode15,
            }
            pub type Reset = Register<
                mode0::Reset,
                mode1::Reset,
                mode2::Reset,
                mode3::Reset,
                mode4::Reset,
                mode5::Reset,
                mode6::Reset,
                mode7::Reset,
                mode8::Reset,
                mode9::Reset,
                mode10::Reset,
                mode11::Reset,
                mode12::Reset,
                mode13::Reset,
                mode14::Reset,
                mode15::Reset,
            >;
            pub struct TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: core::marker::PhantomData<Mode0>,
                pub mode1: core::marker::PhantomData<Mode1>,
                pub mode2: core::marker::PhantomData<Mode2>,
                pub mode3: core::marker::PhantomData<Mode3>,
                pub mode4: core::marker::PhantomData<Mode4>,
                pub mode5: core::marker::PhantomData<Mode5>,
                pub mode6: core::marker::PhantomData<Mode6>,
                pub mode7: core::marker::PhantomData<Mode7>,
                pub mode8: core::marker::PhantomData<Mode8>,
                pub mode9: core::marker::PhantomData<Mode9>,
                pub mode10: core::marker::PhantomData<Mode10>,
                pub mode11: core::marker::PhantomData<Mode11>,
                pub mode12: core::marker::PhantomData<Mode12>,
                pub mode13: core::marker::PhantomData<Mode13>,
                pub mode14: core::marker::PhantomData<Mode14>,
                pub mode15: core::marker::PhantomData<Mode15>,
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        mode0: core::marker::PhantomData,
                        mode1: core::marker::PhantomData,
                        mode2: core::marker::PhantomData,
                        mode3: core::marker::PhantomData,
                        mode4: core::marker::PhantomData,
                        mode5: core::marker::PhantomData,
                        mode6: core::marker::PhantomData,
                        mode7: core::marker::PhantomData,
                        mode8: core::marker::PhantomData,
                        mode9: core::marker::PhantomData,
                        mode10: core::marker::PhantomData,
                        mode11: core::marker::PhantomData,
                        mode12: core::marker::PhantomData,
                        mode13: core::marker::PhantomData,
                        mode14: core::marker::PhantomData,
                        mode15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    let reg_value = ((Mode0::RAW as u32) << mode0::OFFSET)
                        | ((Mode1::RAW as u32) << mode1::OFFSET)
                        | ((Mode2::RAW as u32) << mode2::OFFSET)
                        | ((Mode3::RAW as u32) << mode3::OFFSET)
                        | ((Mode4::RAW as u32) << mode4::OFFSET)
                        | ((Mode5::RAW as u32) << mode5::OFFSET)
                        | ((Mode6::RAW as u32) << mode6::OFFSET)
                        | ((Mode7::RAW as u32) << mode7::OFFSET)
                        | ((Mode8::RAW as u32) << mode8::OFFSET)
                        | ((Mode9::RAW as u32) << mode9::OFFSET)
                        | ((Mode10::RAW as u32) << mode10::OFFSET)
                        | ((Mode11::RAW as u32) << mode11::OFFSET)
                        | ((Mode12::RAW as u32) << mode12::OFFSET)
                        | ((Mode13::RAW as u32) << mode13::OFFSET)
                        | ((Mode14::RAW as u32) << mode14::OFFSET)
                        | ((Mode15::RAW as u32) << mode15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        mode0: unsafe { Mode0::conjure() },
                        mode1: unsafe { Mode1::conjure() },
                        mode2: unsafe { Mode2::conjure() },
                        mode3: unsafe { Mode3::conjure() },
                        mode4: unsafe { Mode4::conjure() },
                        mode5: unsafe { Mode5::conjure() },
                        mode6: unsafe { Mode6::conjure() },
                        mode7: unsafe { Mode7::conjure() },
                        mode8: unsafe { Mode8::conjure() },
                        mode9: unsafe { Mode9::conjure() },
                        mode10: unsafe { Mode10::conjure() },
                        mode11: unsafe { Mode11::conjure() },
                        mode12: unsafe { Mode12::conjure() },
                        mode13: unsafe { Mode13::conjure() },
                        mode14: unsafe { Mode14::conjure() },
                        mode15: unsafe { Mode15::conjure() },
                    }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn transition<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >(
                    self,
                ) -> Register<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >
                where
                    NewMode0: mode0::State,
                    NewMode1: mode1::State,
                    NewMode2: mode2::State,
                    NewMode3: mode3::State,
                    NewMode4: mode4::State,
                    NewMode5: mode5::State,
                    NewMode6: mode6::State,
                    NewMode7: mode7::State,
                    NewMode8: mode8::State,
                    NewMode9: mode9::State,
                    NewMode10: mode10::State,
                    NewMode11: mode11::State,
                    NewMode12: mode12::State,
                    NewMode13: mode13::State,
                    NewMode14: mode14::State,
                    NewMode15: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode1<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    S,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode2<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    S,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode3<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    S,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode4<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    S,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode5<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    S,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode6<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    S,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode7<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    S,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode8<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    S,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode9<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    S,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode10<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    S,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode11<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    S,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode12<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    S,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode13<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    S,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode14<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    S,
                    Mode15,
                >
                where
                    S: mode14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode15<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    S,
                >
                where
                    S: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod otyper {
            pub mod ot0 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot1 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot0::OFFSET + super::ot0::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot0::OFFSET + super::ot0::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot2 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot1::OFFSET + super::ot1::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot1::OFFSET + super::ot1::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot3 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot2::OFFSET + super::ot2::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot2::OFFSET + super::ot2::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot4 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot3::OFFSET + super::ot3::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot3::OFFSET + super::ot3::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot5 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot4::OFFSET + super::ot4::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot4::OFFSET + super::ot4::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot6 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot5::OFFSET + super::ot5::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot5::OFFSET + super::ot5::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot7 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot6::OFFSET + super::ot6::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot6::OFFSET + super::ot6::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot8 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot7::OFFSET + super::ot7::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot7::OFFSET + super::ot7::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot9 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot8::OFFSET + super::ot8::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot8::OFFSET + super::ot8::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot10 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot9::OFFSET + super::ot9::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot9::OFFSET + super::ot9::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot11 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot10::OFFSET + super::ot10::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot10::OFFSET + super::ot10::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot12 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot11::OFFSET + super::ot11::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot11::OFFSET + super::ot11::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot13 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot12::OFFSET + super::ot12::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot12::OFFSET + super::ot12::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot14 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot13::OFFSET + super::ot13::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot13::OFFSET + super::ot13::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot15 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot14::OFFSET + super::ot14::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot14::OFFSET + super::ot14::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::moder::OFFSET + 32 as u32;
            pub struct Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: Ot0,
                pub ot1: Ot1,
                pub ot2: Ot2,
                pub ot3: Ot3,
                pub ot4: Ot4,
                pub ot5: Ot5,
                pub ot6: Ot6,
                pub ot7: Ot7,
                pub ot8: Ot8,
                pub ot9: Ot9,
                pub ot10: Ot10,
                pub ot11: Ot11,
                pub ot12: Ot12,
                pub ot13: Ot13,
                pub ot14: Ot14,
                pub ot15: Ot15,
            }
            pub type Reset = Register<
                ot0::Reset,
                ot1::Reset,
                ot2::Reset,
                ot3::Reset,
                ot4::Reset,
                ot5::Reset,
                ot6::Reset,
                ot7::Reset,
                ot8::Reset,
                ot9::Reset,
                ot10::Reset,
                ot11::Reset,
                ot12::Reset,
                ot13::Reset,
                ot14::Reset,
                ot15::Reset,
            >;
            pub struct TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: core::marker::PhantomData<Ot0>,
                pub ot1: core::marker::PhantomData<Ot1>,
                pub ot2: core::marker::PhantomData<Ot2>,
                pub ot3: core::marker::PhantomData<Ot3>,
                pub ot4: core::marker::PhantomData<Ot4>,
                pub ot5: core::marker::PhantomData<Ot5>,
                pub ot6: core::marker::PhantomData<Ot6>,
                pub ot7: core::marker::PhantomData<Ot7>,
                pub ot8: core::marker::PhantomData<Ot8>,
                pub ot9: core::marker::PhantomData<Ot9>,
                pub ot10: core::marker::PhantomData<Ot10>,
                pub ot11: core::marker::PhantomData<Ot11>,
                pub ot12: core::marker::PhantomData<Ot12>,
                pub ot13: core::marker::PhantomData<Ot13>,
                pub ot14: core::marker::PhantomData<Ot14>,
                pub ot15: core::marker::PhantomData<Ot15>,
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ot0: core::marker::PhantomData,
                        ot1: core::marker::PhantomData,
                        ot2: core::marker::PhantomData,
                        ot3: core::marker::PhantomData,
                        ot4: core::marker::PhantomData,
                        ot5: core::marker::PhantomData,
                        ot6: core::marker::PhantomData,
                        ot7: core::marker::PhantomData,
                        ot8: core::marker::PhantomData,
                        ot9: core::marker::PhantomData,
                        ot10: core::marker::PhantomData,
                        ot11: core::marker::PhantomData,
                        ot12: core::marker::PhantomData,
                        ot13: core::marker::PhantomData,
                        ot14: core::marker::PhantomData,
                        ot15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    let reg_value = ((Ot0::RAW as u32) << ot0::OFFSET)
                        | ((Ot1::RAW as u32) << ot1::OFFSET)
                        | ((Ot2::RAW as u32) << ot2::OFFSET)
                        | ((Ot3::RAW as u32) << ot3::OFFSET)
                        | ((Ot4::RAW as u32) << ot4::OFFSET)
                        | ((Ot5::RAW as u32) << ot5::OFFSET)
                        | ((Ot6::RAW as u32) << ot6::OFFSET)
                        | ((Ot7::RAW as u32) << ot7::OFFSET)
                        | ((Ot8::RAW as u32) << ot8::OFFSET)
                        | ((Ot9::RAW as u32) << ot9::OFFSET)
                        | ((Ot10::RAW as u32) << ot10::OFFSET)
                        | ((Ot11::RAW as u32) << ot11::OFFSET)
                        | ((Ot12::RAW as u32) << ot12::OFFSET)
                        | ((Ot13::RAW as u32) << ot13::OFFSET)
                        | ((Ot14::RAW as u32) << ot14::OFFSET)
                        | ((Ot15::RAW as u32) << ot15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ot0: unsafe { Ot0::conjure() },
                        ot1: unsafe { Ot1::conjure() },
                        ot2: unsafe { Ot2::conjure() },
                        ot3: unsafe { Ot3::conjure() },
                        ot4: unsafe { Ot4::conjure() },
                        ot5: unsafe { Ot5::conjure() },
                        ot6: unsafe { Ot6::conjure() },
                        ot7: unsafe { Ot7::conjure() },
                        ot8: unsafe { Ot8::conjure() },
                        ot9: unsafe { Ot9::conjure() },
                        ot10: unsafe { Ot10::conjure() },
                        ot11: unsafe { Ot11::conjure() },
                        ot12: unsafe { Ot12::conjure() },
                        ot13: unsafe { Ot13::conjure() },
                        ot14: unsafe { Ot14::conjure() },
                        ot15: unsafe { Ot15::conjure() },
                    }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn transition<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >(
                    self,
                ) -> Register<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >
                where
                    NewOt0: ot0::State,
                    NewOt1: ot1::State,
                    NewOt2: ot2::State,
                    NewOt3: ot3::State,
                    NewOt4: ot4::State,
                    NewOt5: ot5::State,
                    NewOt6: ot6::State,
                    NewOt7: ot7::State,
                    NewOt8: ot8::State,
                    NewOt9: ot9::State,
                    NewOt10: ot10::State,
                    NewOt11: ot11::State,
                    NewOt12: ot12::State,
                    NewOt13: ot13::State,
                    NewOt14: ot14::State,
                    NewOt15: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    S,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    S,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    S,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    S,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    S,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    S,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    S,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    S,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    S,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    S,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    S,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    S,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    S,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    S,
                    Ot15,
                >
                where
                    S: ot14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    S,
                >
                where
                    S: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod ospeedr {
            pub mod ospeed0 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed1 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed0::OFFSET + super::ospeed0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed0::OFFSET + super::ospeed0::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed2 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed1::OFFSET + super::ospeed1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed1::OFFSET + super::ospeed1::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed3 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed2::OFFSET + super::ospeed2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed2::OFFSET + super::ospeed2::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed4 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed3::OFFSET + super::ospeed3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed3::OFFSET + super::ospeed3::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed5 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed4::OFFSET + super::ospeed4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed4::OFFSET + super::ospeed4::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed6 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed5::OFFSET + super::ospeed5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed5::OFFSET + super::ospeed5::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed7 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed6::OFFSET + super::ospeed6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed6::OFFSET + super::ospeed6::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed8 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed7::OFFSET + super::ospeed7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed7::OFFSET + super::ospeed7::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed9 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed8::OFFSET + super::ospeed8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed8::OFFSET + super::ospeed8::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed10 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed9::OFFSET + super::ospeed9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed9::OFFSET + super::ospeed9::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed11 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed10::OFFSET + super::ospeed10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed10::OFFSET + super::ospeed10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed12 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed11::OFFSET + super::ospeed11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed11::OFFSET + super::ospeed11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed13 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed12::OFFSET + super::ospeed12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = VeryHigh;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed12::OFFSET + super::ospeed12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed14 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed13::OFFSET + super::ospeed13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed13::OFFSET + super::ospeed13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed15 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed14::OFFSET + super::ospeed14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed14::OFFSET + super::ospeed14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::otyper::OFFSET + 32 as u32;
            pub struct Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: Ospeed0,
                pub ospeed1: Ospeed1,
                pub ospeed2: Ospeed2,
                pub ospeed3: Ospeed3,
                pub ospeed4: Ospeed4,
                pub ospeed5: Ospeed5,
                pub ospeed6: Ospeed6,
                pub ospeed7: Ospeed7,
                pub ospeed8: Ospeed8,
                pub ospeed9: Ospeed9,
                pub ospeed10: Ospeed10,
                pub ospeed11: Ospeed11,
                pub ospeed12: Ospeed12,
                pub ospeed13: Ospeed13,
                pub ospeed14: Ospeed14,
                pub ospeed15: Ospeed15,
            }
            pub type Reset = Register<
                ospeed0::Reset,
                ospeed1::Reset,
                ospeed2::Reset,
                ospeed3::Reset,
                ospeed4::Reset,
                ospeed5::Reset,
                ospeed6::Reset,
                ospeed7::Reset,
                ospeed8::Reset,
                ospeed9::Reset,
                ospeed10::Reset,
                ospeed11::Reset,
                ospeed12::Reset,
                ospeed13::Reset,
                ospeed14::Reset,
                ospeed15::Reset,
            >;
            pub struct TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: core::marker::PhantomData<Ospeed0>,
                pub ospeed1: core::marker::PhantomData<Ospeed1>,
                pub ospeed2: core::marker::PhantomData<Ospeed2>,
                pub ospeed3: core::marker::PhantomData<Ospeed3>,
                pub ospeed4: core::marker::PhantomData<Ospeed4>,
                pub ospeed5: core::marker::PhantomData<Ospeed5>,
                pub ospeed6: core::marker::PhantomData<Ospeed6>,
                pub ospeed7: core::marker::PhantomData<Ospeed7>,
                pub ospeed8: core::marker::PhantomData<Ospeed8>,
                pub ospeed9: core::marker::PhantomData<Ospeed9>,
                pub ospeed10: core::marker::PhantomData<Ospeed10>,
                pub ospeed11: core::marker::PhantomData<Ospeed11>,
                pub ospeed12: core::marker::PhantomData<Ospeed12>,
                pub ospeed13: core::marker::PhantomData<Ospeed13>,
                pub ospeed14: core::marker::PhantomData<Ospeed14>,
                pub ospeed15: core::marker::PhantomData<Ospeed15>,
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ospeed0: core::marker::PhantomData,
                        ospeed1: core::marker::PhantomData,
                        ospeed2: core::marker::PhantomData,
                        ospeed3: core::marker::PhantomData,
                        ospeed4: core::marker::PhantomData,
                        ospeed5: core::marker::PhantomData,
                        ospeed6: core::marker::PhantomData,
                        ospeed7: core::marker::PhantomData,
                        ospeed8: core::marker::PhantomData,
                        ospeed9: core::marker::PhantomData,
                        ospeed10: core::marker::PhantomData,
                        ospeed11: core::marker::PhantomData,
                        ospeed12: core::marker::PhantomData,
                        ospeed13: core::marker::PhantomData,
                        ospeed14: core::marker::PhantomData,
                        ospeed15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    let reg_value = ((Ospeed0::RAW as u32) << ospeed0::OFFSET)
                        | ((Ospeed1::RAW as u32) << ospeed1::OFFSET)
                        | ((Ospeed2::RAW as u32) << ospeed2::OFFSET)
                        | ((Ospeed3::RAW as u32) << ospeed3::OFFSET)
                        | ((Ospeed4::RAW as u32) << ospeed4::OFFSET)
                        | ((Ospeed5::RAW as u32) << ospeed5::OFFSET)
                        | ((Ospeed6::RAW as u32) << ospeed6::OFFSET)
                        | ((Ospeed7::RAW as u32) << ospeed7::OFFSET)
                        | ((Ospeed8::RAW as u32) << ospeed8::OFFSET)
                        | ((Ospeed9::RAW as u32) << ospeed9::OFFSET)
                        | ((Ospeed10::RAW as u32) << ospeed10::OFFSET)
                        | ((Ospeed11::RAW as u32) << ospeed11::OFFSET)
                        | ((Ospeed12::RAW as u32) << ospeed12::OFFSET)
                        | ((Ospeed13::RAW as u32) << ospeed13::OFFSET)
                        | ((Ospeed14::RAW as u32) << ospeed14::OFFSET)
                        | ((Ospeed15::RAW as u32) << ospeed15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ospeed0: unsafe { Ospeed0::conjure() },
                        ospeed1: unsafe { Ospeed1::conjure() },
                        ospeed2: unsafe { Ospeed2::conjure() },
                        ospeed3: unsafe { Ospeed3::conjure() },
                        ospeed4: unsafe { Ospeed4::conjure() },
                        ospeed5: unsafe { Ospeed5::conjure() },
                        ospeed6: unsafe { Ospeed6::conjure() },
                        ospeed7: unsafe { Ospeed7::conjure() },
                        ospeed8: unsafe { Ospeed8::conjure() },
                        ospeed9: unsafe { Ospeed9::conjure() },
                        ospeed10: unsafe { Ospeed10::conjure() },
                        ospeed11: unsafe { Ospeed11::conjure() },
                        ospeed12: unsafe { Ospeed12::conjure() },
                        ospeed13: unsafe { Ospeed13::conjure() },
                        ospeed14: unsafe { Ospeed14::conjure() },
                        ospeed15: unsafe { Ospeed15::conjure() },
                    }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn transition<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >(
                    self,
                ) -> Register<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >
                where
                    NewOspeed0: ospeed0::State,
                    NewOspeed1: ospeed1::State,
                    NewOspeed2: ospeed2::State,
                    NewOspeed3: ospeed3::State,
                    NewOspeed4: ospeed4::State,
                    NewOspeed5: ospeed5::State,
                    NewOspeed6: ospeed6::State,
                    NewOspeed7: ospeed7::State,
                    NewOspeed8: ospeed8::State,
                    NewOspeed9: ospeed9::State,
                    NewOspeed10: ospeed10::State,
                    NewOspeed11: ospeed11::State,
                    NewOspeed12: ospeed12::State,
                    NewOspeed13: ospeed13::State,
                    NewOspeed14: ospeed14::State,
                    NewOspeed15: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    S,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    S,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    S,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    S,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    S,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    S,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    S,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    S,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    S,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    S,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    S,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    S,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    S,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    S,
                    Ospeed15,
                >
                where
                    S: ospeed14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    S,
                >
                where
                    S: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod pupdr {
            pub mod pupd0 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd1 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd0::OFFSET + super::pupd0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd0::OFFSET + super::pupd0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd2 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd1::OFFSET + super::pupd1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd1::OFFSET + super::pupd1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd3 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd2::OFFSET + super::pupd2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd2::OFFSET + super::pupd2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd4 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd3::OFFSET + super::pupd3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd3::OFFSET + super::pupd3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd5 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd4::OFFSET + super::pupd4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd4::OFFSET + super::pupd4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd6 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd5::OFFSET + super::pupd5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd5::OFFSET + super::pupd5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd7 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd6::OFFSET + super::pupd6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd6::OFFSET + super::pupd6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd8 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd7::OFFSET + super::pupd7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd7::OFFSET + super::pupd7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd9 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd8::OFFSET + super::pupd8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd8::OFFSET + super::pupd8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd10 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd9::OFFSET + super::pupd9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd9::OFFSET + super::pupd9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd11 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd10::OFFSET + super::pupd10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd10::OFFSET + super::pupd10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd12 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd11::OFFSET + super::pupd11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd11::OFFSET + super::pupd11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd13 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd12::OFFSET + super::pupd12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PullUp;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd12::OFFSET + super::pupd12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd14 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd13::OFFSET + super::pupd13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PullDown;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd13::OFFSET + super::pupd13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd15 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd14::OFFSET + super::pupd14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PullUp;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd14::OFFSET + super::pupd14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::ospeedr::OFFSET + 32 as u32;
            pub struct Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: Pupd0,
                pub pupd1: Pupd1,
                pub pupd2: Pupd2,
                pub pupd3: Pupd3,
                pub pupd4: Pupd4,
                pub pupd5: Pupd5,
                pub pupd6: Pupd6,
                pub pupd7: Pupd7,
                pub pupd8: Pupd8,
                pub pupd9: Pupd9,
                pub pupd10: Pupd10,
                pub pupd11: Pupd11,
                pub pupd12: Pupd12,
                pub pupd13: Pupd13,
                pub pupd14: Pupd14,
                pub pupd15: Pupd15,
            }
            pub type Reset = Register<
                pupd0::Reset,
                pupd1::Reset,
                pupd2::Reset,
                pupd3::Reset,
                pupd4::Reset,
                pupd5::Reset,
                pupd6::Reset,
                pupd7::Reset,
                pupd8::Reset,
                pupd9::Reset,
                pupd10::Reset,
                pupd11::Reset,
                pupd12::Reset,
                pupd13::Reset,
                pupd14::Reset,
                pupd15::Reset,
            >;
            pub struct TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: core::marker::PhantomData<Pupd0>,
                pub pupd1: core::marker::PhantomData<Pupd1>,
                pub pupd2: core::marker::PhantomData<Pupd2>,
                pub pupd3: core::marker::PhantomData<Pupd3>,
                pub pupd4: core::marker::PhantomData<Pupd4>,
                pub pupd5: core::marker::PhantomData<Pupd5>,
                pub pupd6: core::marker::PhantomData<Pupd6>,
                pub pupd7: core::marker::PhantomData<Pupd7>,
                pub pupd8: core::marker::PhantomData<Pupd8>,
                pub pupd9: core::marker::PhantomData<Pupd9>,
                pub pupd10: core::marker::PhantomData<Pupd10>,
                pub pupd11: core::marker::PhantomData<Pupd11>,
                pub pupd12: core::marker::PhantomData<Pupd12>,
                pub pupd13: core::marker::PhantomData<Pupd13>,
                pub pupd14: core::marker::PhantomData<Pupd14>,
                pub pupd15: core::marker::PhantomData<Pupd15>,
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        pupd0: core::marker::PhantomData,
                        pupd1: core::marker::PhantomData,
                        pupd2: core::marker::PhantomData,
                        pupd3: core::marker::PhantomData,
                        pupd4: core::marker::PhantomData,
                        pupd5: core::marker::PhantomData,
                        pupd6: core::marker::PhantomData,
                        pupd7: core::marker::PhantomData,
                        pupd8: core::marker::PhantomData,
                        pupd9: core::marker::PhantomData,
                        pupd10: core::marker::PhantomData,
                        pupd11: core::marker::PhantomData,
                        pupd12: core::marker::PhantomData,
                        pupd13: core::marker::PhantomData,
                        pupd14: core::marker::PhantomData,
                        pupd15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    let reg_value = ((Pupd0::RAW as u32) << pupd0::OFFSET)
                        | ((Pupd1::RAW as u32) << pupd1::OFFSET)
                        | ((Pupd2::RAW as u32) << pupd2::OFFSET)
                        | ((Pupd3::RAW as u32) << pupd3::OFFSET)
                        | ((Pupd4::RAW as u32) << pupd4::OFFSET)
                        | ((Pupd5::RAW as u32) << pupd5::OFFSET)
                        | ((Pupd6::RAW as u32) << pupd6::OFFSET)
                        | ((Pupd7::RAW as u32) << pupd7::OFFSET)
                        | ((Pupd8::RAW as u32) << pupd8::OFFSET)
                        | ((Pupd9::RAW as u32) << pupd9::OFFSET)
                        | ((Pupd10::RAW as u32) << pupd10::OFFSET)
                        | ((Pupd11::RAW as u32) << pupd11::OFFSET)
                        | ((Pupd12::RAW as u32) << pupd12::OFFSET)
                        | ((Pupd13::RAW as u32) << pupd13::OFFSET)
                        | ((Pupd14::RAW as u32) << pupd14::OFFSET)
                        | ((Pupd15::RAW as u32) << pupd15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        pupd0: unsafe { Pupd0::conjure() },
                        pupd1: unsafe { Pupd1::conjure() },
                        pupd2: unsafe { Pupd2::conjure() },
                        pupd3: unsafe { Pupd3::conjure() },
                        pupd4: unsafe { Pupd4::conjure() },
                        pupd5: unsafe { Pupd5::conjure() },
                        pupd6: unsafe { Pupd6::conjure() },
                        pupd7: unsafe { Pupd7::conjure() },
                        pupd8: unsafe { Pupd8::conjure() },
                        pupd9: unsafe { Pupd9::conjure() },
                        pupd10: unsafe { Pupd10::conjure() },
                        pupd11: unsafe { Pupd11::conjure() },
                        pupd12: unsafe { Pupd12::conjure() },
                        pupd13: unsafe { Pupd13::conjure() },
                        pupd14: unsafe { Pupd14::conjure() },
                        pupd15: unsafe { Pupd15::conjure() },
                    }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn transition<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >(
                    self,
                ) -> Register<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >
                where
                    NewPupd0: pupd0::State,
                    NewPupd1: pupd1::State,
                    NewPupd2: pupd2::State,
                    NewPupd3: pupd3::State,
                    NewPupd4: pupd4::State,
                    NewPupd5: pupd5::State,
                    NewPupd6: pupd6::State,
                    NewPupd7: pupd7::State,
                    NewPupd8: pupd8::State,
                    NewPupd9: pupd9::State,
                    NewPupd10: pupd10::State,
                    NewPupd11: pupd11::State,
                    NewPupd12: pupd12::State,
                    NewPupd13: pupd13::State,
                    NewPupd14: pupd14::State,
                    NewPupd15: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd1<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    S,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd2<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    S,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd3<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    S,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd4<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    S,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd5<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    S,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd6<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    S,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd7<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    S,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd8<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    S,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd9<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    S,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd10<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    S,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd11<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    S,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd12<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    S,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd13<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    S,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd14<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    S,
                    Pupd15,
                >
                where
                    S: pupd14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd15<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    S,
                >
                where
                    S: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub const BASE_ADDR: u32 = 1207959552u32;
        pub struct Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub moder: Moder,
            pub otyper: Otyper,
            pub ospeedr: Ospeedr,
            pub pupdr: Pupdr,
        }
        pub type Reset = Block<
            moder::Reset,
            otyper::Reset,
            ospeedr::Reset,
            pupdr::Reset,
        >;
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn moder<R>(
                self,
                f: impl FnOnce(Moder) -> R,
            ) -> Block<R, Otyper, Ospeedr, Pupdr> {
                Block {
                    moder: f(self.moder),
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn otyper<R>(
                self,
                f: impl FnOnce(Otyper) -> R,
            ) -> Block<Moder, R, Ospeedr, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: f(self.otyper),
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn ospeedr<R>(
                self,
                f: impl FnOnce(Ospeedr) -> R,
            ) -> Block<Moder, Otyper, R, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: f(self.ospeedr),
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn pupdr<R>(
                self,
                f: impl FnOnce(Pupdr) -> R,
            ) -> Block<Moder, Otyper, Ospeedr, R> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: f(self.pupdr),
                }
            }
        }
    }
    mod gpiob {
        pub mod moder {
            pub mod mode0 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode1 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode0::OFFSET + super::mode0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode0::OFFSET + super::mode0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode2 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode1::OFFSET + super::mode1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode1::OFFSET + super::mode1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode3 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode2::OFFSET + super::mode2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Alternate;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode2::OFFSET + super::mode2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode4 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode3::OFFSET + super::mode3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Alternate;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode3::OFFSET + super::mode3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode5 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode4::OFFSET + super::mode4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode4::OFFSET + super::mode4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode6 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode5::OFFSET + super::mode5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode5::OFFSET + super::mode5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode7 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode6::OFFSET + super::mode6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode6::OFFSET + super::mode6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode8 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode7::OFFSET + super::mode7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode7::OFFSET + super::mode7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode9 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode8::OFFSET + super::mode8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode8::OFFSET + super::mode8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode10 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode9::OFFSET + super::mode9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode9::OFFSET + super::mode9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode11 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode10::OFFSET + super::mode10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode10::OFFSET + super::mode10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode12 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode11::OFFSET + super::mode11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode11::OFFSET + super::mode11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode13 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode12::OFFSET + super::mode12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode12::OFFSET + super::mode12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode14 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode13::OFFSET + super::mode13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode13::OFFSET + super::mode13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode15 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode14::OFFSET + super::mode14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode14::OFFSET + super::mode14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = 0 as u32;
            pub struct Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: Mode0,
                pub mode1: Mode1,
                pub mode2: Mode2,
                pub mode3: Mode3,
                pub mode4: Mode4,
                pub mode5: Mode5,
                pub mode6: Mode6,
                pub mode7: Mode7,
                pub mode8: Mode8,
                pub mode9: Mode9,
                pub mode10: Mode10,
                pub mode11: Mode11,
                pub mode12: Mode12,
                pub mode13: Mode13,
                pub mode14: Mode14,
                pub mode15: Mode15,
            }
            pub type Reset = Register<
                mode0::Reset,
                mode1::Reset,
                mode2::Reset,
                mode3::Reset,
                mode4::Reset,
                mode5::Reset,
                mode6::Reset,
                mode7::Reset,
                mode8::Reset,
                mode9::Reset,
                mode10::Reset,
                mode11::Reset,
                mode12::Reset,
                mode13::Reset,
                mode14::Reset,
                mode15::Reset,
            >;
            pub struct TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: core::marker::PhantomData<Mode0>,
                pub mode1: core::marker::PhantomData<Mode1>,
                pub mode2: core::marker::PhantomData<Mode2>,
                pub mode3: core::marker::PhantomData<Mode3>,
                pub mode4: core::marker::PhantomData<Mode4>,
                pub mode5: core::marker::PhantomData<Mode5>,
                pub mode6: core::marker::PhantomData<Mode6>,
                pub mode7: core::marker::PhantomData<Mode7>,
                pub mode8: core::marker::PhantomData<Mode8>,
                pub mode9: core::marker::PhantomData<Mode9>,
                pub mode10: core::marker::PhantomData<Mode10>,
                pub mode11: core::marker::PhantomData<Mode11>,
                pub mode12: core::marker::PhantomData<Mode12>,
                pub mode13: core::marker::PhantomData<Mode13>,
                pub mode14: core::marker::PhantomData<Mode14>,
                pub mode15: core::marker::PhantomData<Mode15>,
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        mode0: core::marker::PhantomData,
                        mode1: core::marker::PhantomData,
                        mode2: core::marker::PhantomData,
                        mode3: core::marker::PhantomData,
                        mode4: core::marker::PhantomData,
                        mode5: core::marker::PhantomData,
                        mode6: core::marker::PhantomData,
                        mode7: core::marker::PhantomData,
                        mode8: core::marker::PhantomData,
                        mode9: core::marker::PhantomData,
                        mode10: core::marker::PhantomData,
                        mode11: core::marker::PhantomData,
                        mode12: core::marker::PhantomData,
                        mode13: core::marker::PhantomData,
                        mode14: core::marker::PhantomData,
                        mode15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    let reg_value = ((Mode0::RAW as u32) << mode0::OFFSET)
                        | ((Mode1::RAW as u32) << mode1::OFFSET)
                        | ((Mode2::RAW as u32) << mode2::OFFSET)
                        | ((Mode3::RAW as u32) << mode3::OFFSET)
                        | ((Mode4::RAW as u32) << mode4::OFFSET)
                        | ((Mode5::RAW as u32) << mode5::OFFSET)
                        | ((Mode6::RAW as u32) << mode6::OFFSET)
                        | ((Mode7::RAW as u32) << mode7::OFFSET)
                        | ((Mode8::RAW as u32) << mode8::OFFSET)
                        | ((Mode9::RAW as u32) << mode9::OFFSET)
                        | ((Mode10::RAW as u32) << mode10::OFFSET)
                        | ((Mode11::RAW as u32) << mode11::OFFSET)
                        | ((Mode12::RAW as u32) << mode12::OFFSET)
                        | ((Mode13::RAW as u32) << mode13::OFFSET)
                        | ((Mode14::RAW as u32) << mode14::OFFSET)
                        | ((Mode15::RAW as u32) << mode15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        mode0: unsafe { Mode0::conjure() },
                        mode1: unsafe { Mode1::conjure() },
                        mode2: unsafe { Mode2::conjure() },
                        mode3: unsafe { Mode3::conjure() },
                        mode4: unsafe { Mode4::conjure() },
                        mode5: unsafe { Mode5::conjure() },
                        mode6: unsafe { Mode6::conjure() },
                        mode7: unsafe { Mode7::conjure() },
                        mode8: unsafe { Mode8::conjure() },
                        mode9: unsafe { Mode9::conjure() },
                        mode10: unsafe { Mode10::conjure() },
                        mode11: unsafe { Mode11::conjure() },
                        mode12: unsafe { Mode12::conjure() },
                        mode13: unsafe { Mode13::conjure() },
                        mode14: unsafe { Mode14::conjure() },
                        mode15: unsafe { Mode15::conjure() },
                    }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn transition<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >(
                    self,
                ) -> Register<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >
                where
                    NewMode0: mode0::State,
                    NewMode1: mode1::State,
                    NewMode2: mode2::State,
                    NewMode3: mode3::State,
                    NewMode4: mode4::State,
                    NewMode5: mode5::State,
                    NewMode6: mode6::State,
                    NewMode7: mode7::State,
                    NewMode8: mode8::State,
                    NewMode9: mode9::State,
                    NewMode10: mode10::State,
                    NewMode11: mode11::State,
                    NewMode12: mode12::State,
                    NewMode13: mode13::State,
                    NewMode14: mode14::State,
                    NewMode15: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode1<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    S,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode2<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    S,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode3<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    S,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode4<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    S,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode5<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    S,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode6<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    S,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode7<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    S,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode8<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    S,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode9<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    S,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode10<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    S,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode11<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    S,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode12<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    S,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode13<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    S,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode14<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    S,
                    Mode15,
                >
                where
                    S: mode14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode15<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    S,
                >
                where
                    S: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod otyper {
            pub mod ot0 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot1 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot0::OFFSET + super::ot0::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot0::OFFSET + super::ot0::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot2 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot1::OFFSET + super::ot1::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot1::OFFSET + super::ot1::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot3 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot2::OFFSET + super::ot2::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot2::OFFSET + super::ot2::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot4 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot3::OFFSET + super::ot3::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot3::OFFSET + super::ot3::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot5 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot4::OFFSET + super::ot4::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot4::OFFSET + super::ot4::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot6 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot5::OFFSET + super::ot5::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot5::OFFSET + super::ot5::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot7 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot6::OFFSET + super::ot6::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot6::OFFSET + super::ot6::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot8 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot7::OFFSET + super::ot7::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot7::OFFSET + super::ot7::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot9 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot8::OFFSET + super::ot8::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot8::OFFSET + super::ot8::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot10 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot9::OFFSET + super::ot9::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot9::OFFSET + super::ot9::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot11 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot10::OFFSET + super::ot10::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot10::OFFSET + super::ot10::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot12 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot11::OFFSET + super::ot11::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot11::OFFSET + super::ot11::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot13 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot12::OFFSET + super::ot12::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot12::OFFSET + super::ot12::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot14 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot13::OFFSET + super::ot13::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot13::OFFSET + super::ot13::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot15 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot14::OFFSET + super::ot14::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot14::OFFSET + super::ot14::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::moder::OFFSET + 32 as u32;
            pub struct Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: Ot0,
                pub ot1: Ot1,
                pub ot2: Ot2,
                pub ot3: Ot3,
                pub ot4: Ot4,
                pub ot5: Ot5,
                pub ot6: Ot6,
                pub ot7: Ot7,
                pub ot8: Ot8,
                pub ot9: Ot9,
                pub ot10: Ot10,
                pub ot11: Ot11,
                pub ot12: Ot12,
                pub ot13: Ot13,
                pub ot14: Ot14,
                pub ot15: Ot15,
            }
            pub type Reset = Register<
                ot0::Reset,
                ot1::Reset,
                ot2::Reset,
                ot3::Reset,
                ot4::Reset,
                ot5::Reset,
                ot6::Reset,
                ot7::Reset,
                ot8::Reset,
                ot9::Reset,
                ot10::Reset,
                ot11::Reset,
                ot12::Reset,
                ot13::Reset,
                ot14::Reset,
                ot15::Reset,
            >;
            pub struct TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: core::marker::PhantomData<Ot0>,
                pub ot1: core::marker::PhantomData<Ot1>,
                pub ot2: core::marker::PhantomData<Ot2>,
                pub ot3: core::marker::PhantomData<Ot3>,
                pub ot4: core::marker::PhantomData<Ot4>,
                pub ot5: core::marker::PhantomData<Ot5>,
                pub ot6: core::marker::PhantomData<Ot6>,
                pub ot7: core::marker::PhantomData<Ot7>,
                pub ot8: core::marker::PhantomData<Ot8>,
                pub ot9: core::marker::PhantomData<Ot9>,
                pub ot10: core::marker::PhantomData<Ot10>,
                pub ot11: core::marker::PhantomData<Ot11>,
                pub ot12: core::marker::PhantomData<Ot12>,
                pub ot13: core::marker::PhantomData<Ot13>,
                pub ot14: core::marker::PhantomData<Ot14>,
                pub ot15: core::marker::PhantomData<Ot15>,
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ot0: core::marker::PhantomData,
                        ot1: core::marker::PhantomData,
                        ot2: core::marker::PhantomData,
                        ot3: core::marker::PhantomData,
                        ot4: core::marker::PhantomData,
                        ot5: core::marker::PhantomData,
                        ot6: core::marker::PhantomData,
                        ot7: core::marker::PhantomData,
                        ot8: core::marker::PhantomData,
                        ot9: core::marker::PhantomData,
                        ot10: core::marker::PhantomData,
                        ot11: core::marker::PhantomData,
                        ot12: core::marker::PhantomData,
                        ot13: core::marker::PhantomData,
                        ot14: core::marker::PhantomData,
                        ot15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    let reg_value = ((Ot0::RAW as u32) << ot0::OFFSET)
                        | ((Ot1::RAW as u32) << ot1::OFFSET)
                        | ((Ot2::RAW as u32) << ot2::OFFSET)
                        | ((Ot3::RAW as u32) << ot3::OFFSET)
                        | ((Ot4::RAW as u32) << ot4::OFFSET)
                        | ((Ot5::RAW as u32) << ot5::OFFSET)
                        | ((Ot6::RAW as u32) << ot6::OFFSET)
                        | ((Ot7::RAW as u32) << ot7::OFFSET)
                        | ((Ot8::RAW as u32) << ot8::OFFSET)
                        | ((Ot9::RAW as u32) << ot9::OFFSET)
                        | ((Ot10::RAW as u32) << ot10::OFFSET)
                        | ((Ot11::RAW as u32) << ot11::OFFSET)
                        | ((Ot12::RAW as u32) << ot12::OFFSET)
                        | ((Ot13::RAW as u32) << ot13::OFFSET)
                        | ((Ot14::RAW as u32) << ot14::OFFSET)
                        | ((Ot15::RAW as u32) << ot15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ot0: unsafe { Ot0::conjure() },
                        ot1: unsafe { Ot1::conjure() },
                        ot2: unsafe { Ot2::conjure() },
                        ot3: unsafe { Ot3::conjure() },
                        ot4: unsafe { Ot4::conjure() },
                        ot5: unsafe { Ot5::conjure() },
                        ot6: unsafe { Ot6::conjure() },
                        ot7: unsafe { Ot7::conjure() },
                        ot8: unsafe { Ot8::conjure() },
                        ot9: unsafe { Ot9::conjure() },
                        ot10: unsafe { Ot10::conjure() },
                        ot11: unsafe { Ot11::conjure() },
                        ot12: unsafe { Ot12::conjure() },
                        ot13: unsafe { Ot13::conjure() },
                        ot14: unsafe { Ot14::conjure() },
                        ot15: unsafe { Ot15::conjure() },
                    }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn transition<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >(
                    self,
                ) -> Register<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >
                where
                    NewOt0: ot0::State,
                    NewOt1: ot1::State,
                    NewOt2: ot2::State,
                    NewOt3: ot3::State,
                    NewOt4: ot4::State,
                    NewOt5: ot5::State,
                    NewOt6: ot6::State,
                    NewOt7: ot7::State,
                    NewOt8: ot8::State,
                    NewOt9: ot9::State,
                    NewOt10: ot10::State,
                    NewOt11: ot11::State,
                    NewOt12: ot12::State,
                    NewOt13: ot13::State,
                    NewOt14: ot14::State,
                    NewOt15: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    S,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    S,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    S,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    S,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    S,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    S,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    S,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    S,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    S,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    S,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    S,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    S,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    S,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    S,
                    Ot15,
                >
                where
                    S: ot14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    S,
                >
                where
                    S: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod ospeedr {
            pub mod ospeed0 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed1 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed0::OFFSET + super::ospeed0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed0::OFFSET + super::ospeed0::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed2 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed1::OFFSET + super::ospeed1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed1::OFFSET + super::ospeed1::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed3 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed2::OFFSET + super::ospeed2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed2::OFFSET + super::ospeed2::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed4 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed3::OFFSET + super::ospeed3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed3::OFFSET + super::ospeed3::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed5 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed4::OFFSET + super::ospeed4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed4::OFFSET + super::ospeed4::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed6 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed5::OFFSET + super::ospeed5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed5::OFFSET + super::ospeed5::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed7 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed6::OFFSET + super::ospeed6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed6::OFFSET + super::ospeed6::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed8 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed7::OFFSET + super::ospeed7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed7::OFFSET + super::ospeed7::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed9 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed8::OFFSET + super::ospeed8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed8::OFFSET + super::ospeed8::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed10 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed9::OFFSET + super::ospeed9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed9::OFFSET + super::ospeed9::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed11 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed10::OFFSET + super::ospeed10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed10::OFFSET + super::ospeed10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed12 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed11::OFFSET + super::ospeed11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed11::OFFSET + super::ospeed11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed13 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed12::OFFSET + super::ospeed12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed12::OFFSET + super::ospeed12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed14 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed13::OFFSET + super::ospeed13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed13::OFFSET + super::ospeed13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed15 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed14::OFFSET + super::ospeed14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed14::OFFSET + super::ospeed14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::otyper::OFFSET + 32 as u32;
            pub struct Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: Ospeed0,
                pub ospeed1: Ospeed1,
                pub ospeed2: Ospeed2,
                pub ospeed3: Ospeed3,
                pub ospeed4: Ospeed4,
                pub ospeed5: Ospeed5,
                pub ospeed6: Ospeed6,
                pub ospeed7: Ospeed7,
                pub ospeed8: Ospeed8,
                pub ospeed9: Ospeed9,
                pub ospeed10: Ospeed10,
                pub ospeed11: Ospeed11,
                pub ospeed12: Ospeed12,
                pub ospeed13: Ospeed13,
                pub ospeed14: Ospeed14,
                pub ospeed15: Ospeed15,
            }
            pub type Reset = Register<
                ospeed0::Reset,
                ospeed1::Reset,
                ospeed2::Reset,
                ospeed3::Reset,
                ospeed4::Reset,
                ospeed5::Reset,
                ospeed6::Reset,
                ospeed7::Reset,
                ospeed8::Reset,
                ospeed9::Reset,
                ospeed10::Reset,
                ospeed11::Reset,
                ospeed12::Reset,
                ospeed13::Reset,
                ospeed14::Reset,
                ospeed15::Reset,
            >;
            pub struct TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: core::marker::PhantomData<Ospeed0>,
                pub ospeed1: core::marker::PhantomData<Ospeed1>,
                pub ospeed2: core::marker::PhantomData<Ospeed2>,
                pub ospeed3: core::marker::PhantomData<Ospeed3>,
                pub ospeed4: core::marker::PhantomData<Ospeed4>,
                pub ospeed5: core::marker::PhantomData<Ospeed5>,
                pub ospeed6: core::marker::PhantomData<Ospeed6>,
                pub ospeed7: core::marker::PhantomData<Ospeed7>,
                pub ospeed8: core::marker::PhantomData<Ospeed8>,
                pub ospeed9: core::marker::PhantomData<Ospeed9>,
                pub ospeed10: core::marker::PhantomData<Ospeed10>,
                pub ospeed11: core::marker::PhantomData<Ospeed11>,
                pub ospeed12: core::marker::PhantomData<Ospeed12>,
                pub ospeed13: core::marker::PhantomData<Ospeed13>,
                pub ospeed14: core::marker::PhantomData<Ospeed14>,
                pub ospeed15: core::marker::PhantomData<Ospeed15>,
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ospeed0: core::marker::PhantomData,
                        ospeed1: core::marker::PhantomData,
                        ospeed2: core::marker::PhantomData,
                        ospeed3: core::marker::PhantomData,
                        ospeed4: core::marker::PhantomData,
                        ospeed5: core::marker::PhantomData,
                        ospeed6: core::marker::PhantomData,
                        ospeed7: core::marker::PhantomData,
                        ospeed8: core::marker::PhantomData,
                        ospeed9: core::marker::PhantomData,
                        ospeed10: core::marker::PhantomData,
                        ospeed11: core::marker::PhantomData,
                        ospeed12: core::marker::PhantomData,
                        ospeed13: core::marker::PhantomData,
                        ospeed14: core::marker::PhantomData,
                        ospeed15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    let reg_value = ((Ospeed0::RAW as u32) << ospeed0::OFFSET)
                        | ((Ospeed1::RAW as u32) << ospeed1::OFFSET)
                        | ((Ospeed2::RAW as u32) << ospeed2::OFFSET)
                        | ((Ospeed3::RAW as u32) << ospeed3::OFFSET)
                        | ((Ospeed4::RAW as u32) << ospeed4::OFFSET)
                        | ((Ospeed5::RAW as u32) << ospeed5::OFFSET)
                        | ((Ospeed6::RAW as u32) << ospeed6::OFFSET)
                        | ((Ospeed7::RAW as u32) << ospeed7::OFFSET)
                        | ((Ospeed8::RAW as u32) << ospeed8::OFFSET)
                        | ((Ospeed9::RAW as u32) << ospeed9::OFFSET)
                        | ((Ospeed10::RAW as u32) << ospeed10::OFFSET)
                        | ((Ospeed11::RAW as u32) << ospeed11::OFFSET)
                        | ((Ospeed12::RAW as u32) << ospeed12::OFFSET)
                        | ((Ospeed13::RAW as u32) << ospeed13::OFFSET)
                        | ((Ospeed14::RAW as u32) << ospeed14::OFFSET)
                        | ((Ospeed15::RAW as u32) << ospeed15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ospeed0: unsafe { Ospeed0::conjure() },
                        ospeed1: unsafe { Ospeed1::conjure() },
                        ospeed2: unsafe { Ospeed2::conjure() },
                        ospeed3: unsafe { Ospeed3::conjure() },
                        ospeed4: unsafe { Ospeed4::conjure() },
                        ospeed5: unsafe { Ospeed5::conjure() },
                        ospeed6: unsafe { Ospeed6::conjure() },
                        ospeed7: unsafe { Ospeed7::conjure() },
                        ospeed8: unsafe { Ospeed8::conjure() },
                        ospeed9: unsafe { Ospeed9::conjure() },
                        ospeed10: unsafe { Ospeed10::conjure() },
                        ospeed11: unsafe { Ospeed11::conjure() },
                        ospeed12: unsafe { Ospeed12::conjure() },
                        ospeed13: unsafe { Ospeed13::conjure() },
                        ospeed14: unsafe { Ospeed14::conjure() },
                        ospeed15: unsafe { Ospeed15::conjure() },
                    }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn transition<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >(
                    self,
                ) -> Register<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >
                where
                    NewOspeed0: ospeed0::State,
                    NewOspeed1: ospeed1::State,
                    NewOspeed2: ospeed2::State,
                    NewOspeed3: ospeed3::State,
                    NewOspeed4: ospeed4::State,
                    NewOspeed5: ospeed5::State,
                    NewOspeed6: ospeed6::State,
                    NewOspeed7: ospeed7::State,
                    NewOspeed8: ospeed8::State,
                    NewOspeed9: ospeed9::State,
                    NewOspeed10: ospeed10::State,
                    NewOspeed11: ospeed11::State,
                    NewOspeed12: ospeed12::State,
                    NewOspeed13: ospeed13::State,
                    NewOspeed14: ospeed14::State,
                    NewOspeed15: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    S,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    S,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    S,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    S,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    S,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    S,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    S,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    S,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    S,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    S,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    S,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    S,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    S,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    S,
                    Ospeed15,
                >
                where
                    S: ospeed14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    S,
                >
                where
                    S: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod pupdr {
            pub mod pupd0 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd1 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd0::OFFSET + super::pupd0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd0::OFFSET + super::pupd0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd2 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd1::OFFSET + super::pupd1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd1::OFFSET + super::pupd1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd3 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd2::OFFSET + super::pupd2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd2::OFFSET + super::pupd2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd4 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd3::OFFSET + super::pupd3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PullUp;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd3::OFFSET + super::pupd3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd5 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd4::OFFSET + super::pupd4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd4::OFFSET + super::pupd4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd6 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd5::OFFSET + super::pupd5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd5::OFFSET + super::pupd5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd7 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd6::OFFSET + super::pupd6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd6::OFFSET + super::pupd6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd8 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd7::OFFSET + super::pupd7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd7::OFFSET + super::pupd7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd9 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd8::OFFSET + super::pupd8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd8::OFFSET + super::pupd8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd10 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd9::OFFSET + super::pupd9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd9::OFFSET + super::pupd9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd11 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd10::OFFSET + super::pupd10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd10::OFFSET + super::pupd10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd12 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd11::OFFSET + super::pupd11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd11::OFFSET + super::pupd11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd13 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd12::OFFSET + super::pupd12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd12::OFFSET + super::pupd12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd14 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd13::OFFSET + super::pupd13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd13::OFFSET + super::pupd13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd15 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd14::OFFSET + super::pupd14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd14::OFFSET + super::pupd14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::ospeedr::OFFSET + 32 as u32;
            pub struct Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: Pupd0,
                pub pupd1: Pupd1,
                pub pupd2: Pupd2,
                pub pupd3: Pupd3,
                pub pupd4: Pupd4,
                pub pupd5: Pupd5,
                pub pupd6: Pupd6,
                pub pupd7: Pupd7,
                pub pupd8: Pupd8,
                pub pupd9: Pupd9,
                pub pupd10: Pupd10,
                pub pupd11: Pupd11,
                pub pupd12: Pupd12,
                pub pupd13: Pupd13,
                pub pupd14: Pupd14,
                pub pupd15: Pupd15,
            }
            pub type Reset = Register<
                pupd0::Reset,
                pupd1::Reset,
                pupd2::Reset,
                pupd3::Reset,
                pupd4::Reset,
                pupd5::Reset,
                pupd6::Reset,
                pupd7::Reset,
                pupd8::Reset,
                pupd9::Reset,
                pupd10::Reset,
                pupd11::Reset,
                pupd12::Reset,
                pupd13::Reset,
                pupd14::Reset,
                pupd15::Reset,
            >;
            pub struct TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: core::marker::PhantomData<Pupd0>,
                pub pupd1: core::marker::PhantomData<Pupd1>,
                pub pupd2: core::marker::PhantomData<Pupd2>,
                pub pupd3: core::marker::PhantomData<Pupd3>,
                pub pupd4: core::marker::PhantomData<Pupd4>,
                pub pupd5: core::marker::PhantomData<Pupd5>,
                pub pupd6: core::marker::PhantomData<Pupd6>,
                pub pupd7: core::marker::PhantomData<Pupd7>,
                pub pupd8: core::marker::PhantomData<Pupd8>,
                pub pupd9: core::marker::PhantomData<Pupd9>,
                pub pupd10: core::marker::PhantomData<Pupd10>,
                pub pupd11: core::marker::PhantomData<Pupd11>,
                pub pupd12: core::marker::PhantomData<Pupd12>,
                pub pupd13: core::marker::PhantomData<Pupd13>,
                pub pupd14: core::marker::PhantomData<Pupd14>,
                pub pupd15: core::marker::PhantomData<Pupd15>,
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        pupd0: core::marker::PhantomData,
                        pupd1: core::marker::PhantomData,
                        pupd2: core::marker::PhantomData,
                        pupd3: core::marker::PhantomData,
                        pupd4: core::marker::PhantomData,
                        pupd5: core::marker::PhantomData,
                        pupd6: core::marker::PhantomData,
                        pupd7: core::marker::PhantomData,
                        pupd8: core::marker::PhantomData,
                        pupd9: core::marker::PhantomData,
                        pupd10: core::marker::PhantomData,
                        pupd11: core::marker::PhantomData,
                        pupd12: core::marker::PhantomData,
                        pupd13: core::marker::PhantomData,
                        pupd14: core::marker::PhantomData,
                        pupd15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    let reg_value = ((Pupd0::RAW as u32) << pupd0::OFFSET)
                        | ((Pupd1::RAW as u32) << pupd1::OFFSET)
                        | ((Pupd2::RAW as u32) << pupd2::OFFSET)
                        | ((Pupd3::RAW as u32) << pupd3::OFFSET)
                        | ((Pupd4::RAW as u32) << pupd4::OFFSET)
                        | ((Pupd5::RAW as u32) << pupd5::OFFSET)
                        | ((Pupd6::RAW as u32) << pupd6::OFFSET)
                        | ((Pupd7::RAW as u32) << pupd7::OFFSET)
                        | ((Pupd8::RAW as u32) << pupd8::OFFSET)
                        | ((Pupd9::RAW as u32) << pupd9::OFFSET)
                        | ((Pupd10::RAW as u32) << pupd10::OFFSET)
                        | ((Pupd11::RAW as u32) << pupd11::OFFSET)
                        | ((Pupd12::RAW as u32) << pupd12::OFFSET)
                        | ((Pupd13::RAW as u32) << pupd13::OFFSET)
                        | ((Pupd14::RAW as u32) << pupd14::OFFSET)
                        | ((Pupd15::RAW as u32) << pupd15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        pupd0: unsafe { Pupd0::conjure() },
                        pupd1: unsafe { Pupd1::conjure() },
                        pupd2: unsafe { Pupd2::conjure() },
                        pupd3: unsafe { Pupd3::conjure() },
                        pupd4: unsafe { Pupd4::conjure() },
                        pupd5: unsafe { Pupd5::conjure() },
                        pupd6: unsafe { Pupd6::conjure() },
                        pupd7: unsafe { Pupd7::conjure() },
                        pupd8: unsafe { Pupd8::conjure() },
                        pupd9: unsafe { Pupd9::conjure() },
                        pupd10: unsafe { Pupd10::conjure() },
                        pupd11: unsafe { Pupd11::conjure() },
                        pupd12: unsafe { Pupd12::conjure() },
                        pupd13: unsafe { Pupd13::conjure() },
                        pupd14: unsafe { Pupd14::conjure() },
                        pupd15: unsafe { Pupd15::conjure() },
                    }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn transition<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >(
                    self,
                ) -> Register<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >
                where
                    NewPupd0: pupd0::State,
                    NewPupd1: pupd1::State,
                    NewPupd2: pupd2::State,
                    NewPupd3: pupd3::State,
                    NewPupd4: pupd4::State,
                    NewPupd5: pupd5::State,
                    NewPupd6: pupd6::State,
                    NewPupd7: pupd7::State,
                    NewPupd8: pupd8::State,
                    NewPupd9: pupd9::State,
                    NewPupd10: pupd10::State,
                    NewPupd11: pupd11::State,
                    NewPupd12: pupd12::State,
                    NewPupd13: pupd13::State,
                    NewPupd14: pupd14::State,
                    NewPupd15: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd1<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    S,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd2<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    S,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd3<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    S,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd4<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    S,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd5<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    S,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd6<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    S,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd7<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    S,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd8<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    S,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd9<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    S,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd10<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    S,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd11<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    S,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd12<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    S,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd13<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    S,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd14<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    S,
                    Pupd15,
                >
                where
                    S: pupd14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd15<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    S,
                >
                where
                    S: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub const BASE_ADDR: u32 = 1207960576u32;
        pub struct Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub moder: Moder,
            pub otyper: Otyper,
            pub ospeedr: Ospeedr,
            pub pupdr: Pupdr,
        }
        pub type Reset = Block<
            moder::Reset,
            otyper::Reset,
            ospeedr::Reset,
            pupdr::Reset,
        >;
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn moder<R>(
                self,
                f: impl FnOnce(Moder) -> R,
            ) -> Block<R, Otyper, Ospeedr, Pupdr> {
                Block {
                    moder: f(self.moder),
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn otyper<R>(
                self,
                f: impl FnOnce(Otyper) -> R,
            ) -> Block<Moder, R, Ospeedr, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: f(self.otyper),
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn ospeedr<R>(
                self,
                f: impl FnOnce(Ospeedr) -> R,
            ) -> Block<Moder, Otyper, R, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: f(self.ospeedr),
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn pupdr<R>(
                self,
                f: impl FnOnce(Pupdr) -> R,
            ) -> Block<Moder, Otyper, Ospeedr, R> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: f(self.pupdr),
                }
            }
        }
    }
    mod gpioc {
        pub mod moder {
            pub mod mode0 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode1 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode0::OFFSET + super::mode0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode0::OFFSET + super::mode0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode2 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode1::OFFSET + super::mode1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode1::OFFSET + super::mode1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode3 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode2::OFFSET + super::mode2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode2::OFFSET + super::mode2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode4 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode3::OFFSET + super::mode3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode3::OFFSET + super::mode3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode5 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode4::OFFSET + super::mode4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode4::OFFSET + super::mode4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode6 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode5::OFFSET + super::mode5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode5::OFFSET + super::mode5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode7 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode6::OFFSET + super::mode6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode6::OFFSET + super::mode6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode8 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode7::OFFSET + super::mode7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode7::OFFSET + super::mode7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode9 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode8::OFFSET + super::mode8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode8::OFFSET + super::mode8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode10 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode9::OFFSET + super::mode9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode9::OFFSET + super::mode9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode11 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode10::OFFSET + super::mode10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode10::OFFSET + super::mode10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode12 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode11::OFFSET + super::mode11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode11::OFFSET + super::mode11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode13 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode12::OFFSET + super::mode12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode12::OFFSET + super::mode12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode14 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode13::OFFSET + super::mode13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode13::OFFSET + super::mode13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode15 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode14::OFFSET + super::mode14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode14::OFFSET + super::mode14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = 0 as u32;
            pub struct Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: Mode0,
                pub mode1: Mode1,
                pub mode2: Mode2,
                pub mode3: Mode3,
                pub mode4: Mode4,
                pub mode5: Mode5,
                pub mode6: Mode6,
                pub mode7: Mode7,
                pub mode8: Mode8,
                pub mode9: Mode9,
                pub mode10: Mode10,
                pub mode11: Mode11,
                pub mode12: Mode12,
                pub mode13: Mode13,
                pub mode14: Mode14,
                pub mode15: Mode15,
            }
            pub type Reset = Register<
                mode0::Reset,
                mode1::Reset,
                mode2::Reset,
                mode3::Reset,
                mode4::Reset,
                mode5::Reset,
                mode6::Reset,
                mode7::Reset,
                mode8::Reset,
                mode9::Reset,
                mode10::Reset,
                mode11::Reset,
                mode12::Reset,
                mode13::Reset,
                mode14::Reset,
                mode15::Reset,
            >;
            pub struct TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: core::marker::PhantomData<Mode0>,
                pub mode1: core::marker::PhantomData<Mode1>,
                pub mode2: core::marker::PhantomData<Mode2>,
                pub mode3: core::marker::PhantomData<Mode3>,
                pub mode4: core::marker::PhantomData<Mode4>,
                pub mode5: core::marker::PhantomData<Mode5>,
                pub mode6: core::marker::PhantomData<Mode6>,
                pub mode7: core::marker::PhantomData<Mode7>,
                pub mode8: core::marker::PhantomData<Mode8>,
                pub mode9: core::marker::PhantomData<Mode9>,
                pub mode10: core::marker::PhantomData<Mode10>,
                pub mode11: core::marker::PhantomData<Mode11>,
                pub mode12: core::marker::PhantomData<Mode12>,
                pub mode13: core::marker::PhantomData<Mode13>,
                pub mode14: core::marker::PhantomData<Mode14>,
                pub mode15: core::marker::PhantomData<Mode15>,
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        mode0: core::marker::PhantomData,
                        mode1: core::marker::PhantomData,
                        mode2: core::marker::PhantomData,
                        mode3: core::marker::PhantomData,
                        mode4: core::marker::PhantomData,
                        mode5: core::marker::PhantomData,
                        mode6: core::marker::PhantomData,
                        mode7: core::marker::PhantomData,
                        mode8: core::marker::PhantomData,
                        mode9: core::marker::PhantomData,
                        mode10: core::marker::PhantomData,
                        mode11: core::marker::PhantomData,
                        mode12: core::marker::PhantomData,
                        mode13: core::marker::PhantomData,
                        mode14: core::marker::PhantomData,
                        mode15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    let reg_value = ((Mode0::RAW as u32) << mode0::OFFSET)
                        | ((Mode1::RAW as u32) << mode1::OFFSET)
                        | ((Mode2::RAW as u32) << mode2::OFFSET)
                        | ((Mode3::RAW as u32) << mode3::OFFSET)
                        | ((Mode4::RAW as u32) << mode4::OFFSET)
                        | ((Mode5::RAW as u32) << mode5::OFFSET)
                        | ((Mode6::RAW as u32) << mode6::OFFSET)
                        | ((Mode7::RAW as u32) << mode7::OFFSET)
                        | ((Mode8::RAW as u32) << mode8::OFFSET)
                        | ((Mode9::RAW as u32) << mode9::OFFSET)
                        | ((Mode10::RAW as u32) << mode10::OFFSET)
                        | ((Mode11::RAW as u32) << mode11::OFFSET)
                        | ((Mode12::RAW as u32) << mode12::OFFSET)
                        | ((Mode13::RAW as u32) << mode13::OFFSET)
                        | ((Mode14::RAW as u32) << mode14::OFFSET)
                        | ((Mode15::RAW as u32) << mode15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        mode0: unsafe { Mode0::conjure() },
                        mode1: unsafe { Mode1::conjure() },
                        mode2: unsafe { Mode2::conjure() },
                        mode3: unsafe { Mode3::conjure() },
                        mode4: unsafe { Mode4::conjure() },
                        mode5: unsafe { Mode5::conjure() },
                        mode6: unsafe { Mode6::conjure() },
                        mode7: unsafe { Mode7::conjure() },
                        mode8: unsafe { Mode8::conjure() },
                        mode9: unsafe { Mode9::conjure() },
                        mode10: unsafe { Mode10::conjure() },
                        mode11: unsafe { Mode11::conjure() },
                        mode12: unsafe { Mode12::conjure() },
                        mode13: unsafe { Mode13::conjure() },
                        mode14: unsafe { Mode14::conjure() },
                        mode15: unsafe { Mode15::conjure() },
                    }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn transition<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >(
                    self,
                ) -> Register<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >
                where
                    NewMode0: mode0::State,
                    NewMode1: mode1::State,
                    NewMode2: mode2::State,
                    NewMode3: mode3::State,
                    NewMode4: mode4::State,
                    NewMode5: mode5::State,
                    NewMode6: mode6::State,
                    NewMode7: mode7::State,
                    NewMode8: mode8::State,
                    NewMode9: mode9::State,
                    NewMode10: mode10::State,
                    NewMode11: mode11::State,
                    NewMode12: mode12::State,
                    NewMode13: mode13::State,
                    NewMode14: mode14::State,
                    NewMode15: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode1<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    S,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode2<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    S,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode3<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    S,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode4<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    S,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode5<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    S,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode6<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    S,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode7<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    S,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode8<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    S,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode9<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    S,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode10<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    S,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode11<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    S,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode12<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    S,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode13<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    S,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode14<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    S,
                    Mode15,
                >
                where
                    S: mode14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode15<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    S,
                >
                where
                    S: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod otyper {
            pub mod ot0 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot1 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot0::OFFSET + super::ot0::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot0::OFFSET + super::ot0::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot2 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot1::OFFSET + super::ot1::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot1::OFFSET + super::ot1::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot3 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot2::OFFSET + super::ot2::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot2::OFFSET + super::ot2::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot4 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot3::OFFSET + super::ot3::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot3::OFFSET + super::ot3::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot5 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot4::OFFSET + super::ot4::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot4::OFFSET + super::ot4::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot6 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot5::OFFSET + super::ot5::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot5::OFFSET + super::ot5::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot7 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot6::OFFSET + super::ot6::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot6::OFFSET + super::ot6::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot8 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot7::OFFSET + super::ot7::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot7::OFFSET + super::ot7::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot9 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot8::OFFSET + super::ot8::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot8::OFFSET + super::ot8::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot10 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot9::OFFSET + super::ot9::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot9::OFFSET + super::ot9::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot11 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot10::OFFSET + super::ot10::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot10::OFFSET + super::ot10::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot12 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot11::OFFSET + super::ot11::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot11::OFFSET + super::ot11::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot13 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot12::OFFSET + super::ot12::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot12::OFFSET + super::ot12::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot14 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot13::OFFSET + super::ot13::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot13::OFFSET + super::ot13::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot15 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot14::OFFSET + super::ot14::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot14::OFFSET + super::ot14::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::moder::OFFSET + 32 as u32;
            pub struct Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: Ot0,
                pub ot1: Ot1,
                pub ot2: Ot2,
                pub ot3: Ot3,
                pub ot4: Ot4,
                pub ot5: Ot5,
                pub ot6: Ot6,
                pub ot7: Ot7,
                pub ot8: Ot8,
                pub ot9: Ot9,
                pub ot10: Ot10,
                pub ot11: Ot11,
                pub ot12: Ot12,
                pub ot13: Ot13,
                pub ot14: Ot14,
                pub ot15: Ot15,
            }
            pub type Reset = Register<
                ot0::Reset,
                ot1::Reset,
                ot2::Reset,
                ot3::Reset,
                ot4::Reset,
                ot5::Reset,
                ot6::Reset,
                ot7::Reset,
                ot8::Reset,
                ot9::Reset,
                ot10::Reset,
                ot11::Reset,
                ot12::Reset,
                ot13::Reset,
                ot14::Reset,
                ot15::Reset,
            >;
            pub struct TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: core::marker::PhantomData<Ot0>,
                pub ot1: core::marker::PhantomData<Ot1>,
                pub ot2: core::marker::PhantomData<Ot2>,
                pub ot3: core::marker::PhantomData<Ot3>,
                pub ot4: core::marker::PhantomData<Ot4>,
                pub ot5: core::marker::PhantomData<Ot5>,
                pub ot6: core::marker::PhantomData<Ot6>,
                pub ot7: core::marker::PhantomData<Ot7>,
                pub ot8: core::marker::PhantomData<Ot8>,
                pub ot9: core::marker::PhantomData<Ot9>,
                pub ot10: core::marker::PhantomData<Ot10>,
                pub ot11: core::marker::PhantomData<Ot11>,
                pub ot12: core::marker::PhantomData<Ot12>,
                pub ot13: core::marker::PhantomData<Ot13>,
                pub ot14: core::marker::PhantomData<Ot14>,
                pub ot15: core::marker::PhantomData<Ot15>,
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ot0: core::marker::PhantomData,
                        ot1: core::marker::PhantomData,
                        ot2: core::marker::PhantomData,
                        ot3: core::marker::PhantomData,
                        ot4: core::marker::PhantomData,
                        ot5: core::marker::PhantomData,
                        ot6: core::marker::PhantomData,
                        ot7: core::marker::PhantomData,
                        ot8: core::marker::PhantomData,
                        ot9: core::marker::PhantomData,
                        ot10: core::marker::PhantomData,
                        ot11: core::marker::PhantomData,
                        ot12: core::marker::PhantomData,
                        ot13: core::marker::PhantomData,
                        ot14: core::marker::PhantomData,
                        ot15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    let reg_value = ((Ot0::RAW as u32) << ot0::OFFSET)
                        | ((Ot1::RAW as u32) << ot1::OFFSET)
                        | ((Ot2::RAW as u32) << ot2::OFFSET)
                        | ((Ot3::RAW as u32) << ot3::OFFSET)
                        | ((Ot4::RAW as u32) << ot4::OFFSET)
                        | ((Ot5::RAW as u32) << ot5::OFFSET)
                        | ((Ot6::RAW as u32) << ot6::OFFSET)
                        | ((Ot7::RAW as u32) << ot7::OFFSET)
                        | ((Ot8::RAW as u32) << ot8::OFFSET)
                        | ((Ot9::RAW as u32) << ot9::OFFSET)
                        | ((Ot10::RAW as u32) << ot10::OFFSET)
                        | ((Ot11::RAW as u32) << ot11::OFFSET)
                        | ((Ot12::RAW as u32) << ot12::OFFSET)
                        | ((Ot13::RAW as u32) << ot13::OFFSET)
                        | ((Ot14::RAW as u32) << ot14::OFFSET)
                        | ((Ot15::RAW as u32) << ot15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ot0: unsafe { Ot0::conjure() },
                        ot1: unsafe { Ot1::conjure() },
                        ot2: unsafe { Ot2::conjure() },
                        ot3: unsafe { Ot3::conjure() },
                        ot4: unsafe { Ot4::conjure() },
                        ot5: unsafe { Ot5::conjure() },
                        ot6: unsafe { Ot6::conjure() },
                        ot7: unsafe { Ot7::conjure() },
                        ot8: unsafe { Ot8::conjure() },
                        ot9: unsafe { Ot9::conjure() },
                        ot10: unsafe { Ot10::conjure() },
                        ot11: unsafe { Ot11::conjure() },
                        ot12: unsafe { Ot12::conjure() },
                        ot13: unsafe { Ot13::conjure() },
                        ot14: unsafe { Ot14::conjure() },
                        ot15: unsafe { Ot15::conjure() },
                    }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn transition<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >(
                    self,
                ) -> Register<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >
                where
                    NewOt0: ot0::State,
                    NewOt1: ot1::State,
                    NewOt2: ot2::State,
                    NewOt3: ot3::State,
                    NewOt4: ot4::State,
                    NewOt5: ot5::State,
                    NewOt6: ot6::State,
                    NewOt7: ot7::State,
                    NewOt8: ot8::State,
                    NewOt9: ot9::State,
                    NewOt10: ot10::State,
                    NewOt11: ot11::State,
                    NewOt12: ot12::State,
                    NewOt13: ot13::State,
                    NewOt14: ot14::State,
                    NewOt15: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    S,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    S,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    S,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    S,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    S,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    S,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    S,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    S,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    S,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    S,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    S,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    S,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    S,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    S,
                    Ot15,
                >
                where
                    S: ot14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    S,
                >
                where
                    S: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod ospeedr {
            pub mod ospeed0 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed1 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed0::OFFSET + super::ospeed0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed0::OFFSET + super::ospeed0::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed2 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed1::OFFSET + super::ospeed1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed1::OFFSET + super::ospeed1::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed3 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed2::OFFSET + super::ospeed2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed2::OFFSET + super::ospeed2::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed4 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed3::OFFSET + super::ospeed3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed3::OFFSET + super::ospeed3::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed5 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed4::OFFSET + super::ospeed4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed4::OFFSET + super::ospeed4::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed6 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed5::OFFSET + super::ospeed5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed5::OFFSET + super::ospeed5::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed7 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed6::OFFSET + super::ospeed6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed6::OFFSET + super::ospeed6::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed8 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed7::OFFSET + super::ospeed7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed7::OFFSET + super::ospeed7::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed9 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed8::OFFSET + super::ospeed8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed8::OFFSET + super::ospeed8::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed10 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed9::OFFSET + super::ospeed9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed9::OFFSET + super::ospeed9::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed11 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed10::OFFSET + super::ospeed10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed10::OFFSET + super::ospeed10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed12 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed11::OFFSET + super::ospeed11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed11::OFFSET + super::ospeed11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed13 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed12::OFFSET + super::ospeed12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed12::OFFSET + super::ospeed12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed14 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed13::OFFSET + super::ospeed13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed13::OFFSET + super::ospeed13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed15 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed14::OFFSET + super::ospeed14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed14::OFFSET + super::ospeed14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::otyper::OFFSET + 32 as u32;
            pub struct Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: Ospeed0,
                pub ospeed1: Ospeed1,
                pub ospeed2: Ospeed2,
                pub ospeed3: Ospeed3,
                pub ospeed4: Ospeed4,
                pub ospeed5: Ospeed5,
                pub ospeed6: Ospeed6,
                pub ospeed7: Ospeed7,
                pub ospeed8: Ospeed8,
                pub ospeed9: Ospeed9,
                pub ospeed10: Ospeed10,
                pub ospeed11: Ospeed11,
                pub ospeed12: Ospeed12,
                pub ospeed13: Ospeed13,
                pub ospeed14: Ospeed14,
                pub ospeed15: Ospeed15,
            }
            pub type Reset = Register<
                ospeed0::Reset,
                ospeed1::Reset,
                ospeed2::Reset,
                ospeed3::Reset,
                ospeed4::Reset,
                ospeed5::Reset,
                ospeed6::Reset,
                ospeed7::Reset,
                ospeed8::Reset,
                ospeed9::Reset,
                ospeed10::Reset,
                ospeed11::Reset,
                ospeed12::Reset,
                ospeed13::Reset,
                ospeed14::Reset,
                ospeed15::Reset,
            >;
            pub struct TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: core::marker::PhantomData<Ospeed0>,
                pub ospeed1: core::marker::PhantomData<Ospeed1>,
                pub ospeed2: core::marker::PhantomData<Ospeed2>,
                pub ospeed3: core::marker::PhantomData<Ospeed3>,
                pub ospeed4: core::marker::PhantomData<Ospeed4>,
                pub ospeed5: core::marker::PhantomData<Ospeed5>,
                pub ospeed6: core::marker::PhantomData<Ospeed6>,
                pub ospeed7: core::marker::PhantomData<Ospeed7>,
                pub ospeed8: core::marker::PhantomData<Ospeed8>,
                pub ospeed9: core::marker::PhantomData<Ospeed9>,
                pub ospeed10: core::marker::PhantomData<Ospeed10>,
                pub ospeed11: core::marker::PhantomData<Ospeed11>,
                pub ospeed12: core::marker::PhantomData<Ospeed12>,
                pub ospeed13: core::marker::PhantomData<Ospeed13>,
                pub ospeed14: core::marker::PhantomData<Ospeed14>,
                pub ospeed15: core::marker::PhantomData<Ospeed15>,
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ospeed0: core::marker::PhantomData,
                        ospeed1: core::marker::PhantomData,
                        ospeed2: core::marker::PhantomData,
                        ospeed3: core::marker::PhantomData,
                        ospeed4: core::marker::PhantomData,
                        ospeed5: core::marker::PhantomData,
                        ospeed6: core::marker::PhantomData,
                        ospeed7: core::marker::PhantomData,
                        ospeed8: core::marker::PhantomData,
                        ospeed9: core::marker::PhantomData,
                        ospeed10: core::marker::PhantomData,
                        ospeed11: core::marker::PhantomData,
                        ospeed12: core::marker::PhantomData,
                        ospeed13: core::marker::PhantomData,
                        ospeed14: core::marker::PhantomData,
                        ospeed15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    let reg_value = ((Ospeed0::RAW as u32) << ospeed0::OFFSET)
                        | ((Ospeed1::RAW as u32) << ospeed1::OFFSET)
                        | ((Ospeed2::RAW as u32) << ospeed2::OFFSET)
                        | ((Ospeed3::RAW as u32) << ospeed3::OFFSET)
                        | ((Ospeed4::RAW as u32) << ospeed4::OFFSET)
                        | ((Ospeed5::RAW as u32) << ospeed5::OFFSET)
                        | ((Ospeed6::RAW as u32) << ospeed6::OFFSET)
                        | ((Ospeed7::RAW as u32) << ospeed7::OFFSET)
                        | ((Ospeed8::RAW as u32) << ospeed8::OFFSET)
                        | ((Ospeed9::RAW as u32) << ospeed9::OFFSET)
                        | ((Ospeed10::RAW as u32) << ospeed10::OFFSET)
                        | ((Ospeed11::RAW as u32) << ospeed11::OFFSET)
                        | ((Ospeed12::RAW as u32) << ospeed12::OFFSET)
                        | ((Ospeed13::RAW as u32) << ospeed13::OFFSET)
                        | ((Ospeed14::RAW as u32) << ospeed14::OFFSET)
                        | ((Ospeed15::RAW as u32) << ospeed15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ospeed0: unsafe { Ospeed0::conjure() },
                        ospeed1: unsafe { Ospeed1::conjure() },
                        ospeed2: unsafe { Ospeed2::conjure() },
                        ospeed3: unsafe { Ospeed3::conjure() },
                        ospeed4: unsafe { Ospeed4::conjure() },
                        ospeed5: unsafe { Ospeed5::conjure() },
                        ospeed6: unsafe { Ospeed6::conjure() },
                        ospeed7: unsafe { Ospeed7::conjure() },
                        ospeed8: unsafe { Ospeed8::conjure() },
                        ospeed9: unsafe { Ospeed9::conjure() },
                        ospeed10: unsafe { Ospeed10::conjure() },
                        ospeed11: unsafe { Ospeed11::conjure() },
                        ospeed12: unsafe { Ospeed12::conjure() },
                        ospeed13: unsafe { Ospeed13::conjure() },
                        ospeed14: unsafe { Ospeed14::conjure() },
                        ospeed15: unsafe { Ospeed15::conjure() },
                    }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn transition<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >(
                    self,
                ) -> Register<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >
                where
                    NewOspeed0: ospeed0::State,
                    NewOspeed1: ospeed1::State,
                    NewOspeed2: ospeed2::State,
                    NewOspeed3: ospeed3::State,
                    NewOspeed4: ospeed4::State,
                    NewOspeed5: ospeed5::State,
                    NewOspeed6: ospeed6::State,
                    NewOspeed7: ospeed7::State,
                    NewOspeed8: ospeed8::State,
                    NewOspeed9: ospeed9::State,
                    NewOspeed10: ospeed10::State,
                    NewOspeed11: ospeed11::State,
                    NewOspeed12: ospeed12::State,
                    NewOspeed13: ospeed13::State,
                    NewOspeed14: ospeed14::State,
                    NewOspeed15: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    S,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    S,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    S,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    S,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    S,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    S,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    S,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    S,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    S,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    S,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    S,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    S,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    S,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    S,
                    Ospeed15,
                >
                where
                    S: ospeed14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    S,
                >
                where
                    S: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod pupdr {
            pub mod pupd0 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd1 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd0::OFFSET + super::pupd0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd0::OFFSET + super::pupd0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd2 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd1::OFFSET + super::pupd1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd1::OFFSET + super::pupd1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd3 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd2::OFFSET + super::pupd2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd2::OFFSET + super::pupd2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd4 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd3::OFFSET + super::pupd3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd3::OFFSET + super::pupd3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd5 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd4::OFFSET + super::pupd4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd4::OFFSET + super::pupd4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd6 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd5::OFFSET + super::pupd5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd5::OFFSET + super::pupd5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd7 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd6::OFFSET + super::pupd6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd6::OFFSET + super::pupd6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd8 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd7::OFFSET + super::pupd7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd7::OFFSET + super::pupd7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd9 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd8::OFFSET + super::pupd8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd8::OFFSET + super::pupd8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd10 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd9::OFFSET + super::pupd9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd9::OFFSET + super::pupd9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd11 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd10::OFFSET + super::pupd10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd10::OFFSET + super::pupd10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd12 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd11::OFFSET + super::pupd11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd11::OFFSET + super::pupd11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd13 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd12::OFFSET + super::pupd12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd12::OFFSET + super::pupd12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd14 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd13::OFFSET + super::pupd13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd13::OFFSET + super::pupd13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd15 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd14::OFFSET + super::pupd14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd14::OFFSET + super::pupd14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::ospeedr::OFFSET + 32 as u32;
            pub struct Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: Pupd0,
                pub pupd1: Pupd1,
                pub pupd2: Pupd2,
                pub pupd3: Pupd3,
                pub pupd4: Pupd4,
                pub pupd5: Pupd5,
                pub pupd6: Pupd6,
                pub pupd7: Pupd7,
                pub pupd8: Pupd8,
                pub pupd9: Pupd9,
                pub pupd10: Pupd10,
                pub pupd11: Pupd11,
                pub pupd12: Pupd12,
                pub pupd13: Pupd13,
                pub pupd14: Pupd14,
                pub pupd15: Pupd15,
            }
            pub type Reset = Register<
                pupd0::Reset,
                pupd1::Reset,
                pupd2::Reset,
                pupd3::Reset,
                pupd4::Reset,
                pupd5::Reset,
                pupd6::Reset,
                pupd7::Reset,
                pupd8::Reset,
                pupd9::Reset,
                pupd10::Reset,
                pupd11::Reset,
                pupd12::Reset,
                pupd13::Reset,
                pupd14::Reset,
                pupd15::Reset,
            >;
            pub struct TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: core::marker::PhantomData<Pupd0>,
                pub pupd1: core::marker::PhantomData<Pupd1>,
                pub pupd2: core::marker::PhantomData<Pupd2>,
                pub pupd3: core::marker::PhantomData<Pupd3>,
                pub pupd4: core::marker::PhantomData<Pupd4>,
                pub pupd5: core::marker::PhantomData<Pupd5>,
                pub pupd6: core::marker::PhantomData<Pupd6>,
                pub pupd7: core::marker::PhantomData<Pupd7>,
                pub pupd8: core::marker::PhantomData<Pupd8>,
                pub pupd9: core::marker::PhantomData<Pupd9>,
                pub pupd10: core::marker::PhantomData<Pupd10>,
                pub pupd11: core::marker::PhantomData<Pupd11>,
                pub pupd12: core::marker::PhantomData<Pupd12>,
                pub pupd13: core::marker::PhantomData<Pupd13>,
                pub pupd14: core::marker::PhantomData<Pupd14>,
                pub pupd15: core::marker::PhantomData<Pupd15>,
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        pupd0: core::marker::PhantomData,
                        pupd1: core::marker::PhantomData,
                        pupd2: core::marker::PhantomData,
                        pupd3: core::marker::PhantomData,
                        pupd4: core::marker::PhantomData,
                        pupd5: core::marker::PhantomData,
                        pupd6: core::marker::PhantomData,
                        pupd7: core::marker::PhantomData,
                        pupd8: core::marker::PhantomData,
                        pupd9: core::marker::PhantomData,
                        pupd10: core::marker::PhantomData,
                        pupd11: core::marker::PhantomData,
                        pupd12: core::marker::PhantomData,
                        pupd13: core::marker::PhantomData,
                        pupd14: core::marker::PhantomData,
                        pupd15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    let reg_value = ((Pupd0::RAW as u32) << pupd0::OFFSET)
                        | ((Pupd1::RAW as u32) << pupd1::OFFSET)
                        | ((Pupd2::RAW as u32) << pupd2::OFFSET)
                        | ((Pupd3::RAW as u32) << pupd3::OFFSET)
                        | ((Pupd4::RAW as u32) << pupd4::OFFSET)
                        | ((Pupd5::RAW as u32) << pupd5::OFFSET)
                        | ((Pupd6::RAW as u32) << pupd6::OFFSET)
                        | ((Pupd7::RAW as u32) << pupd7::OFFSET)
                        | ((Pupd8::RAW as u32) << pupd8::OFFSET)
                        | ((Pupd9::RAW as u32) << pupd9::OFFSET)
                        | ((Pupd10::RAW as u32) << pupd10::OFFSET)
                        | ((Pupd11::RAW as u32) << pupd11::OFFSET)
                        | ((Pupd12::RAW as u32) << pupd12::OFFSET)
                        | ((Pupd13::RAW as u32) << pupd13::OFFSET)
                        | ((Pupd14::RAW as u32) << pupd14::OFFSET)
                        | ((Pupd15::RAW as u32) << pupd15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        pupd0: unsafe { Pupd0::conjure() },
                        pupd1: unsafe { Pupd1::conjure() },
                        pupd2: unsafe { Pupd2::conjure() },
                        pupd3: unsafe { Pupd3::conjure() },
                        pupd4: unsafe { Pupd4::conjure() },
                        pupd5: unsafe { Pupd5::conjure() },
                        pupd6: unsafe { Pupd6::conjure() },
                        pupd7: unsafe { Pupd7::conjure() },
                        pupd8: unsafe { Pupd8::conjure() },
                        pupd9: unsafe { Pupd9::conjure() },
                        pupd10: unsafe { Pupd10::conjure() },
                        pupd11: unsafe { Pupd11::conjure() },
                        pupd12: unsafe { Pupd12::conjure() },
                        pupd13: unsafe { Pupd13::conjure() },
                        pupd14: unsafe { Pupd14::conjure() },
                        pupd15: unsafe { Pupd15::conjure() },
                    }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn transition<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >(
                    self,
                ) -> Register<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >
                where
                    NewPupd0: pupd0::State,
                    NewPupd1: pupd1::State,
                    NewPupd2: pupd2::State,
                    NewPupd3: pupd3::State,
                    NewPupd4: pupd4::State,
                    NewPupd5: pupd5::State,
                    NewPupd6: pupd6::State,
                    NewPupd7: pupd7::State,
                    NewPupd8: pupd8::State,
                    NewPupd9: pupd9::State,
                    NewPupd10: pupd10::State,
                    NewPupd11: pupd11::State,
                    NewPupd12: pupd12::State,
                    NewPupd13: pupd13::State,
                    NewPupd14: pupd14::State,
                    NewPupd15: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd1<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    S,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd2<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    S,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd3<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    S,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd4<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    S,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd5<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    S,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd6<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    S,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd7<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    S,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd8<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    S,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd9<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    S,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd10<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    S,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd11<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    S,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd12<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    S,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd13<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    S,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd14<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    S,
                    Pupd15,
                >
                where
                    S: pupd14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd15<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    S,
                >
                where
                    S: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub const BASE_ADDR: u32 = 1207960576u32;
        pub struct Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub moder: Moder,
            pub otyper: Otyper,
            pub ospeedr: Ospeedr,
            pub pupdr: Pupdr,
        }
        pub type Reset = Block<
            moder::Reset,
            otyper::Reset,
            ospeedr::Reset,
            pupdr::Reset,
        >;
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn moder<R>(
                self,
                f: impl FnOnce(Moder) -> R,
            ) -> Block<R, Otyper, Ospeedr, Pupdr> {
                Block {
                    moder: f(self.moder),
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn otyper<R>(
                self,
                f: impl FnOnce(Otyper) -> R,
            ) -> Block<Moder, R, Ospeedr, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: f(self.otyper),
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn ospeedr<R>(
                self,
                f: impl FnOnce(Ospeedr) -> R,
            ) -> Block<Moder, Otyper, R, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: f(self.ospeedr),
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn pupdr<R>(
                self,
                f: impl FnOnce(Pupdr) -> R,
            ) -> Block<Moder, Otyper, Ospeedr, R> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: f(self.pupdr),
                }
            }
        }
    }
    mod gpiod {
        pub mod moder {
            pub mod mode0 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode1 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode0::OFFSET + super::mode0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode0::OFFSET + super::mode0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode2 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode1::OFFSET + super::mode1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode1::OFFSET + super::mode1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode3 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode2::OFFSET + super::mode2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode2::OFFSET + super::mode2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode4 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode3::OFFSET + super::mode3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode3::OFFSET + super::mode3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode5 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode4::OFFSET + super::mode4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode4::OFFSET + super::mode4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode6 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode5::OFFSET + super::mode5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode5::OFFSET + super::mode5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode7 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode6::OFFSET + super::mode6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode6::OFFSET + super::mode6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode8 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode7::OFFSET + super::mode7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode7::OFFSET + super::mode7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode9 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode8::OFFSET + super::mode8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode8::OFFSET + super::mode8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode10 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode9::OFFSET + super::mode9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode9::OFFSET + super::mode9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode11 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode10::OFFSET + super::mode10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode10::OFFSET + super::mode10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode12 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode11::OFFSET + super::mode11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode11::OFFSET + super::mode11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode13 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode12::OFFSET + super::mode12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode12::OFFSET + super::mode12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode14 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode13::OFFSET + super::mode13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode13::OFFSET + super::mode13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode15 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode14::OFFSET + super::mode14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode14::OFFSET + super::mode14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = 0 as u32;
            pub struct Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: Mode0,
                pub mode1: Mode1,
                pub mode2: Mode2,
                pub mode3: Mode3,
                pub mode4: Mode4,
                pub mode5: Mode5,
                pub mode6: Mode6,
                pub mode7: Mode7,
                pub mode8: Mode8,
                pub mode9: Mode9,
                pub mode10: Mode10,
                pub mode11: Mode11,
                pub mode12: Mode12,
                pub mode13: Mode13,
                pub mode14: Mode14,
                pub mode15: Mode15,
            }
            pub type Reset = Register<
                mode0::Reset,
                mode1::Reset,
                mode2::Reset,
                mode3::Reset,
                mode4::Reset,
                mode5::Reset,
                mode6::Reset,
                mode7::Reset,
                mode8::Reset,
                mode9::Reset,
                mode10::Reset,
                mode11::Reset,
                mode12::Reset,
                mode13::Reset,
                mode14::Reset,
                mode15::Reset,
            >;
            pub struct TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: core::marker::PhantomData<Mode0>,
                pub mode1: core::marker::PhantomData<Mode1>,
                pub mode2: core::marker::PhantomData<Mode2>,
                pub mode3: core::marker::PhantomData<Mode3>,
                pub mode4: core::marker::PhantomData<Mode4>,
                pub mode5: core::marker::PhantomData<Mode5>,
                pub mode6: core::marker::PhantomData<Mode6>,
                pub mode7: core::marker::PhantomData<Mode7>,
                pub mode8: core::marker::PhantomData<Mode8>,
                pub mode9: core::marker::PhantomData<Mode9>,
                pub mode10: core::marker::PhantomData<Mode10>,
                pub mode11: core::marker::PhantomData<Mode11>,
                pub mode12: core::marker::PhantomData<Mode12>,
                pub mode13: core::marker::PhantomData<Mode13>,
                pub mode14: core::marker::PhantomData<Mode14>,
                pub mode15: core::marker::PhantomData<Mode15>,
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        mode0: core::marker::PhantomData,
                        mode1: core::marker::PhantomData,
                        mode2: core::marker::PhantomData,
                        mode3: core::marker::PhantomData,
                        mode4: core::marker::PhantomData,
                        mode5: core::marker::PhantomData,
                        mode6: core::marker::PhantomData,
                        mode7: core::marker::PhantomData,
                        mode8: core::marker::PhantomData,
                        mode9: core::marker::PhantomData,
                        mode10: core::marker::PhantomData,
                        mode11: core::marker::PhantomData,
                        mode12: core::marker::PhantomData,
                        mode13: core::marker::PhantomData,
                        mode14: core::marker::PhantomData,
                        mode15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    let reg_value = ((Mode0::RAW as u32) << mode0::OFFSET)
                        | ((Mode1::RAW as u32) << mode1::OFFSET)
                        | ((Mode2::RAW as u32) << mode2::OFFSET)
                        | ((Mode3::RAW as u32) << mode3::OFFSET)
                        | ((Mode4::RAW as u32) << mode4::OFFSET)
                        | ((Mode5::RAW as u32) << mode5::OFFSET)
                        | ((Mode6::RAW as u32) << mode6::OFFSET)
                        | ((Mode7::RAW as u32) << mode7::OFFSET)
                        | ((Mode8::RAW as u32) << mode8::OFFSET)
                        | ((Mode9::RAW as u32) << mode9::OFFSET)
                        | ((Mode10::RAW as u32) << mode10::OFFSET)
                        | ((Mode11::RAW as u32) << mode11::OFFSET)
                        | ((Mode12::RAW as u32) << mode12::OFFSET)
                        | ((Mode13::RAW as u32) << mode13::OFFSET)
                        | ((Mode14::RAW as u32) << mode14::OFFSET)
                        | ((Mode15::RAW as u32) << mode15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        mode0: unsafe { Mode0::conjure() },
                        mode1: unsafe { Mode1::conjure() },
                        mode2: unsafe { Mode2::conjure() },
                        mode3: unsafe { Mode3::conjure() },
                        mode4: unsafe { Mode4::conjure() },
                        mode5: unsafe { Mode5::conjure() },
                        mode6: unsafe { Mode6::conjure() },
                        mode7: unsafe { Mode7::conjure() },
                        mode8: unsafe { Mode8::conjure() },
                        mode9: unsafe { Mode9::conjure() },
                        mode10: unsafe { Mode10::conjure() },
                        mode11: unsafe { Mode11::conjure() },
                        mode12: unsafe { Mode12::conjure() },
                        mode13: unsafe { Mode13::conjure() },
                        mode14: unsafe { Mode14::conjure() },
                        mode15: unsafe { Mode15::conjure() },
                    }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn transition<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >(
                    self,
                ) -> Register<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >
                where
                    NewMode0: mode0::State,
                    NewMode1: mode1::State,
                    NewMode2: mode2::State,
                    NewMode3: mode3::State,
                    NewMode4: mode4::State,
                    NewMode5: mode5::State,
                    NewMode6: mode6::State,
                    NewMode7: mode7::State,
                    NewMode8: mode8::State,
                    NewMode9: mode9::State,
                    NewMode10: mode10::State,
                    NewMode11: mode11::State,
                    NewMode12: mode12::State,
                    NewMode13: mode13::State,
                    NewMode14: mode14::State,
                    NewMode15: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode1<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    S,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode2<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    S,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode3<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    S,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode4<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    S,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode5<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    S,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode6<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    S,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode7<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    S,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode8<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    S,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode9<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    S,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode10<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    S,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode11<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    S,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode12<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    S,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode13<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    S,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode14<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    S,
                    Mode15,
                >
                where
                    S: mode14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode15<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    S,
                >
                where
                    S: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod otyper {
            pub mod ot0 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot1 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot0::OFFSET + super::ot0::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot0::OFFSET + super::ot0::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot2 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot1::OFFSET + super::ot1::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot1::OFFSET + super::ot1::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot3 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot2::OFFSET + super::ot2::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot2::OFFSET + super::ot2::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot4 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot3::OFFSET + super::ot3::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot3::OFFSET + super::ot3::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot5 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot4::OFFSET + super::ot4::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot4::OFFSET + super::ot4::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot6 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot5::OFFSET + super::ot5::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot5::OFFSET + super::ot5::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot7 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot6::OFFSET + super::ot6::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot6::OFFSET + super::ot6::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot8 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot7::OFFSET + super::ot7::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot7::OFFSET + super::ot7::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot9 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot8::OFFSET + super::ot8::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot8::OFFSET + super::ot8::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot10 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot9::OFFSET + super::ot9::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot9::OFFSET + super::ot9::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot11 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot10::OFFSET + super::ot10::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot10::OFFSET + super::ot10::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot12 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot11::OFFSET + super::ot11::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot11::OFFSET + super::ot11::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot13 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot12::OFFSET + super::ot12::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot12::OFFSET + super::ot12::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot14 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot13::OFFSET + super::ot13::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot13::OFFSET + super::ot13::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot15 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot14::OFFSET + super::ot14::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot14::OFFSET + super::ot14::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::moder::OFFSET + 32 as u32;
            pub struct Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: Ot0,
                pub ot1: Ot1,
                pub ot2: Ot2,
                pub ot3: Ot3,
                pub ot4: Ot4,
                pub ot5: Ot5,
                pub ot6: Ot6,
                pub ot7: Ot7,
                pub ot8: Ot8,
                pub ot9: Ot9,
                pub ot10: Ot10,
                pub ot11: Ot11,
                pub ot12: Ot12,
                pub ot13: Ot13,
                pub ot14: Ot14,
                pub ot15: Ot15,
            }
            pub type Reset = Register<
                ot0::Reset,
                ot1::Reset,
                ot2::Reset,
                ot3::Reset,
                ot4::Reset,
                ot5::Reset,
                ot6::Reset,
                ot7::Reset,
                ot8::Reset,
                ot9::Reset,
                ot10::Reset,
                ot11::Reset,
                ot12::Reset,
                ot13::Reset,
                ot14::Reset,
                ot15::Reset,
            >;
            pub struct TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: core::marker::PhantomData<Ot0>,
                pub ot1: core::marker::PhantomData<Ot1>,
                pub ot2: core::marker::PhantomData<Ot2>,
                pub ot3: core::marker::PhantomData<Ot3>,
                pub ot4: core::marker::PhantomData<Ot4>,
                pub ot5: core::marker::PhantomData<Ot5>,
                pub ot6: core::marker::PhantomData<Ot6>,
                pub ot7: core::marker::PhantomData<Ot7>,
                pub ot8: core::marker::PhantomData<Ot8>,
                pub ot9: core::marker::PhantomData<Ot9>,
                pub ot10: core::marker::PhantomData<Ot10>,
                pub ot11: core::marker::PhantomData<Ot11>,
                pub ot12: core::marker::PhantomData<Ot12>,
                pub ot13: core::marker::PhantomData<Ot13>,
                pub ot14: core::marker::PhantomData<Ot14>,
                pub ot15: core::marker::PhantomData<Ot15>,
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ot0: core::marker::PhantomData,
                        ot1: core::marker::PhantomData,
                        ot2: core::marker::PhantomData,
                        ot3: core::marker::PhantomData,
                        ot4: core::marker::PhantomData,
                        ot5: core::marker::PhantomData,
                        ot6: core::marker::PhantomData,
                        ot7: core::marker::PhantomData,
                        ot8: core::marker::PhantomData,
                        ot9: core::marker::PhantomData,
                        ot10: core::marker::PhantomData,
                        ot11: core::marker::PhantomData,
                        ot12: core::marker::PhantomData,
                        ot13: core::marker::PhantomData,
                        ot14: core::marker::PhantomData,
                        ot15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    let reg_value = ((Ot0::RAW as u32) << ot0::OFFSET)
                        | ((Ot1::RAW as u32) << ot1::OFFSET)
                        | ((Ot2::RAW as u32) << ot2::OFFSET)
                        | ((Ot3::RAW as u32) << ot3::OFFSET)
                        | ((Ot4::RAW as u32) << ot4::OFFSET)
                        | ((Ot5::RAW as u32) << ot5::OFFSET)
                        | ((Ot6::RAW as u32) << ot6::OFFSET)
                        | ((Ot7::RAW as u32) << ot7::OFFSET)
                        | ((Ot8::RAW as u32) << ot8::OFFSET)
                        | ((Ot9::RAW as u32) << ot9::OFFSET)
                        | ((Ot10::RAW as u32) << ot10::OFFSET)
                        | ((Ot11::RAW as u32) << ot11::OFFSET)
                        | ((Ot12::RAW as u32) << ot12::OFFSET)
                        | ((Ot13::RAW as u32) << ot13::OFFSET)
                        | ((Ot14::RAW as u32) << ot14::OFFSET)
                        | ((Ot15::RAW as u32) << ot15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ot0: unsafe { Ot0::conjure() },
                        ot1: unsafe { Ot1::conjure() },
                        ot2: unsafe { Ot2::conjure() },
                        ot3: unsafe { Ot3::conjure() },
                        ot4: unsafe { Ot4::conjure() },
                        ot5: unsafe { Ot5::conjure() },
                        ot6: unsafe { Ot6::conjure() },
                        ot7: unsafe { Ot7::conjure() },
                        ot8: unsafe { Ot8::conjure() },
                        ot9: unsafe { Ot9::conjure() },
                        ot10: unsafe { Ot10::conjure() },
                        ot11: unsafe { Ot11::conjure() },
                        ot12: unsafe { Ot12::conjure() },
                        ot13: unsafe { Ot13::conjure() },
                        ot14: unsafe { Ot14::conjure() },
                        ot15: unsafe { Ot15::conjure() },
                    }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn transition<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >(
                    self,
                ) -> Register<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >
                where
                    NewOt0: ot0::State,
                    NewOt1: ot1::State,
                    NewOt2: ot2::State,
                    NewOt3: ot3::State,
                    NewOt4: ot4::State,
                    NewOt5: ot5::State,
                    NewOt6: ot6::State,
                    NewOt7: ot7::State,
                    NewOt8: ot8::State,
                    NewOt9: ot9::State,
                    NewOt10: ot10::State,
                    NewOt11: ot11::State,
                    NewOt12: ot12::State,
                    NewOt13: ot13::State,
                    NewOt14: ot14::State,
                    NewOt15: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    S,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    S,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    S,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    S,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    S,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    S,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    S,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    S,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    S,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    S,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    S,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    S,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    S,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    S,
                    Ot15,
                >
                where
                    S: ot14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    S,
                >
                where
                    S: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod ospeedr {
            pub mod ospeed0 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed1 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed0::OFFSET + super::ospeed0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed0::OFFSET + super::ospeed0::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed2 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed1::OFFSET + super::ospeed1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed1::OFFSET + super::ospeed1::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed3 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed2::OFFSET + super::ospeed2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed2::OFFSET + super::ospeed2::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed4 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed3::OFFSET + super::ospeed3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed3::OFFSET + super::ospeed3::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed5 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed4::OFFSET + super::ospeed4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed4::OFFSET + super::ospeed4::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed6 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed5::OFFSET + super::ospeed5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed5::OFFSET + super::ospeed5::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed7 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed6::OFFSET + super::ospeed6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed6::OFFSET + super::ospeed6::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed8 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed7::OFFSET + super::ospeed7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed7::OFFSET + super::ospeed7::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed9 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed8::OFFSET + super::ospeed8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed8::OFFSET + super::ospeed8::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed10 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed9::OFFSET + super::ospeed9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed9::OFFSET + super::ospeed9::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed11 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed10::OFFSET + super::ospeed10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed10::OFFSET + super::ospeed10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed12 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed11::OFFSET + super::ospeed11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed11::OFFSET + super::ospeed11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed13 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed12::OFFSET + super::ospeed12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed12::OFFSET + super::ospeed12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed14 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed13::OFFSET + super::ospeed13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed13::OFFSET + super::ospeed13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed15 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed14::OFFSET + super::ospeed14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed14::OFFSET + super::ospeed14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::otyper::OFFSET + 32 as u32;
            pub struct Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: Ospeed0,
                pub ospeed1: Ospeed1,
                pub ospeed2: Ospeed2,
                pub ospeed3: Ospeed3,
                pub ospeed4: Ospeed4,
                pub ospeed5: Ospeed5,
                pub ospeed6: Ospeed6,
                pub ospeed7: Ospeed7,
                pub ospeed8: Ospeed8,
                pub ospeed9: Ospeed9,
                pub ospeed10: Ospeed10,
                pub ospeed11: Ospeed11,
                pub ospeed12: Ospeed12,
                pub ospeed13: Ospeed13,
                pub ospeed14: Ospeed14,
                pub ospeed15: Ospeed15,
            }
            pub type Reset = Register<
                ospeed0::Reset,
                ospeed1::Reset,
                ospeed2::Reset,
                ospeed3::Reset,
                ospeed4::Reset,
                ospeed5::Reset,
                ospeed6::Reset,
                ospeed7::Reset,
                ospeed8::Reset,
                ospeed9::Reset,
                ospeed10::Reset,
                ospeed11::Reset,
                ospeed12::Reset,
                ospeed13::Reset,
                ospeed14::Reset,
                ospeed15::Reset,
            >;
            pub struct TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: core::marker::PhantomData<Ospeed0>,
                pub ospeed1: core::marker::PhantomData<Ospeed1>,
                pub ospeed2: core::marker::PhantomData<Ospeed2>,
                pub ospeed3: core::marker::PhantomData<Ospeed3>,
                pub ospeed4: core::marker::PhantomData<Ospeed4>,
                pub ospeed5: core::marker::PhantomData<Ospeed5>,
                pub ospeed6: core::marker::PhantomData<Ospeed6>,
                pub ospeed7: core::marker::PhantomData<Ospeed7>,
                pub ospeed8: core::marker::PhantomData<Ospeed8>,
                pub ospeed9: core::marker::PhantomData<Ospeed9>,
                pub ospeed10: core::marker::PhantomData<Ospeed10>,
                pub ospeed11: core::marker::PhantomData<Ospeed11>,
                pub ospeed12: core::marker::PhantomData<Ospeed12>,
                pub ospeed13: core::marker::PhantomData<Ospeed13>,
                pub ospeed14: core::marker::PhantomData<Ospeed14>,
                pub ospeed15: core::marker::PhantomData<Ospeed15>,
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ospeed0: core::marker::PhantomData,
                        ospeed1: core::marker::PhantomData,
                        ospeed2: core::marker::PhantomData,
                        ospeed3: core::marker::PhantomData,
                        ospeed4: core::marker::PhantomData,
                        ospeed5: core::marker::PhantomData,
                        ospeed6: core::marker::PhantomData,
                        ospeed7: core::marker::PhantomData,
                        ospeed8: core::marker::PhantomData,
                        ospeed9: core::marker::PhantomData,
                        ospeed10: core::marker::PhantomData,
                        ospeed11: core::marker::PhantomData,
                        ospeed12: core::marker::PhantomData,
                        ospeed13: core::marker::PhantomData,
                        ospeed14: core::marker::PhantomData,
                        ospeed15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    let reg_value = ((Ospeed0::RAW as u32) << ospeed0::OFFSET)
                        | ((Ospeed1::RAW as u32) << ospeed1::OFFSET)
                        | ((Ospeed2::RAW as u32) << ospeed2::OFFSET)
                        | ((Ospeed3::RAW as u32) << ospeed3::OFFSET)
                        | ((Ospeed4::RAW as u32) << ospeed4::OFFSET)
                        | ((Ospeed5::RAW as u32) << ospeed5::OFFSET)
                        | ((Ospeed6::RAW as u32) << ospeed6::OFFSET)
                        | ((Ospeed7::RAW as u32) << ospeed7::OFFSET)
                        | ((Ospeed8::RAW as u32) << ospeed8::OFFSET)
                        | ((Ospeed9::RAW as u32) << ospeed9::OFFSET)
                        | ((Ospeed10::RAW as u32) << ospeed10::OFFSET)
                        | ((Ospeed11::RAW as u32) << ospeed11::OFFSET)
                        | ((Ospeed12::RAW as u32) << ospeed12::OFFSET)
                        | ((Ospeed13::RAW as u32) << ospeed13::OFFSET)
                        | ((Ospeed14::RAW as u32) << ospeed14::OFFSET)
                        | ((Ospeed15::RAW as u32) << ospeed15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ospeed0: unsafe { Ospeed0::conjure() },
                        ospeed1: unsafe { Ospeed1::conjure() },
                        ospeed2: unsafe { Ospeed2::conjure() },
                        ospeed3: unsafe { Ospeed3::conjure() },
                        ospeed4: unsafe { Ospeed4::conjure() },
                        ospeed5: unsafe { Ospeed5::conjure() },
                        ospeed6: unsafe { Ospeed6::conjure() },
                        ospeed7: unsafe { Ospeed7::conjure() },
                        ospeed8: unsafe { Ospeed8::conjure() },
                        ospeed9: unsafe { Ospeed9::conjure() },
                        ospeed10: unsafe { Ospeed10::conjure() },
                        ospeed11: unsafe { Ospeed11::conjure() },
                        ospeed12: unsafe { Ospeed12::conjure() },
                        ospeed13: unsafe { Ospeed13::conjure() },
                        ospeed14: unsafe { Ospeed14::conjure() },
                        ospeed15: unsafe { Ospeed15::conjure() },
                    }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn transition<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >(
                    self,
                ) -> Register<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >
                where
                    NewOspeed0: ospeed0::State,
                    NewOspeed1: ospeed1::State,
                    NewOspeed2: ospeed2::State,
                    NewOspeed3: ospeed3::State,
                    NewOspeed4: ospeed4::State,
                    NewOspeed5: ospeed5::State,
                    NewOspeed6: ospeed6::State,
                    NewOspeed7: ospeed7::State,
                    NewOspeed8: ospeed8::State,
                    NewOspeed9: ospeed9::State,
                    NewOspeed10: ospeed10::State,
                    NewOspeed11: ospeed11::State,
                    NewOspeed12: ospeed12::State,
                    NewOspeed13: ospeed13::State,
                    NewOspeed14: ospeed14::State,
                    NewOspeed15: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    S,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    S,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    S,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    S,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    S,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    S,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    S,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    S,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    S,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    S,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    S,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    S,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    S,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    S,
                    Ospeed15,
                >
                where
                    S: ospeed14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    S,
                >
                where
                    S: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod pupdr {
            pub mod pupd0 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd1 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd0::OFFSET + super::pupd0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd0::OFFSET + super::pupd0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd2 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd1::OFFSET + super::pupd1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd1::OFFSET + super::pupd1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd3 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd2::OFFSET + super::pupd2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd2::OFFSET + super::pupd2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd4 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd3::OFFSET + super::pupd3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd3::OFFSET + super::pupd3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd5 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd4::OFFSET + super::pupd4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd4::OFFSET + super::pupd4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd6 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd5::OFFSET + super::pupd5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd5::OFFSET + super::pupd5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd7 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd6::OFFSET + super::pupd6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd6::OFFSET + super::pupd6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd8 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd7::OFFSET + super::pupd7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd7::OFFSET + super::pupd7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd9 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd8::OFFSET + super::pupd8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd8::OFFSET + super::pupd8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd10 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd9::OFFSET + super::pupd9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd9::OFFSET + super::pupd9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd11 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd10::OFFSET + super::pupd10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd10::OFFSET + super::pupd10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd12 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd11::OFFSET + super::pupd11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd11::OFFSET + super::pupd11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd13 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd12::OFFSET + super::pupd12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd12::OFFSET + super::pupd12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd14 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd13::OFFSET + super::pupd13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd13::OFFSET + super::pupd13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd15 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd14::OFFSET + super::pupd14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd14::OFFSET + super::pupd14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::ospeedr::OFFSET + 32 as u32;
            pub struct Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: Pupd0,
                pub pupd1: Pupd1,
                pub pupd2: Pupd2,
                pub pupd3: Pupd3,
                pub pupd4: Pupd4,
                pub pupd5: Pupd5,
                pub pupd6: Pupd6,
                pub pupd7: Pupd7,
                pub pupd8: Pupd8,
                pub pupd9: Pupd9,
                pub pupd10: Pupd10,
                pub pupd11: Pupd11,
                pub pupd12: Pupd12,
                pub pupd13: Pupd13,
                pub pupd14: Pupd14,
                pub pupd15: Pupd15,
            }
            pub type Reset = Register<
                pupd0::Reset,
                pupd1::Reset,
                pupd2::Reset,
                pupd3::Reset,
                pupd4::Reset,
                pupd5::Reset,
                pupd6::Reset,
                pupd7::Reset,
                pupd8::Reset,
                pupd9::Reset,
                pupd10::Reset,
                pupd11::Reset,
                pupd12::Reset,
                pupd13::Reset,
                pupd14::Reset,
                pupd15::Reset,
            >;
            pub struct TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: core::marker::PhantomData<Pupd0>,
                pub pupd1: core::marker::PhantomData<Pupd1>,
                pub pupd2: core::marker::PhantomData<Pupd2>,
                pub pupd3: core::marker::PhantomData<Pupd3>,
                pub pupd4: core::marker::PhantomData<Pupd4>,
                pub pupd5: core::marker::PhantomData<Pupd5>,
                pub pupd6: core::marker::PhantomData<Pupd6>,
                pub pupd7: core::marker::PhantomData<Pupd7>,
                pub pupd8: core::marker::PhantomData<Pupd8>,
                pub pupd9: core::marker::PhantomData<Pupd9>,
                pub pupd10: core::marker::PhantomData<Pupd10>,
                pub pupd11: core::marker::PhantomData<Pupd11>,
                pub pupd12: core::marker::PhantomData<Pupd12>,
                pub pupd13: core::marker::PhantomData<Pupd13>,
                pub pupd14: core::marker::PhantomData<Pupd14>,
                pub pupd15: core::marker::PhantomData<Pupd15>,
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        pupd0: core::marker::PhantomData,
                        pupd1: core::marker::PhantomData,
                        pupd2: core::marker::PhantomData,
                        pupd3: core::marker::PhantomData,
                        pupd4: core::marker::PhantomData,
                        pupd5: core::marker::PhantomData,
                        pupd6: core::marker::PhantomData,
                        pupd7: core::marker::PhantomData,
                        pupd8: core::marker::PhantomData,
                        pupd9: core::marker::PhantomData,
                        pupd10: core::marker::PhantomData,
                        pupd11: core::marker::PhantomData,
                        pupd12: core::marker::PhantomData,
                        pupd13: core::marker::PhantomData,
                        pupd14: core::marker::PhantomData,
                        pupd15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    let reg_value = ((Pupd0::RAW as u32) << pupd0::OFFSET)
                        | ((Pupd1::RAW as u32) << pupd1::OFFSET)
                        | ((Pupd2::RAW as u32) << pupd2::OFFSET)
                        | ((Pupd3::RAW as u32) << pupd3::OFFSET)
                        | ((Pupd4::RAW as u32) << pupd4::OFFSET)
                        | ((Pupd5::RAW as u32) << pupd5::OFFSET)
                        | ((Pupd6::RAW as u32) << pupd6::OFFSET)
                        | ((Pupd7::RAW as u32) << pupd7::OFFSET)
                        | ((Pupd8::RAW as u32) << pupd8::OFFSET)
                        | ((Pupd9::RAW as u32) << pupd9::OFFSET)
                        | ((Pupd10::RAW as u32) << pupd10::OFFSET)
                        | ((Pupd11::RAW as u32) << pupd11::OFFSET)
                        | ((Pupd12::RAW as u32) << pupd12::OFFSET)
                        | ((Pupd13::RAW as u32) << pupd13::OFFSET)
                        | ((Pupd14::RAW as u32) << pupd14::OFFSET)
                        | ((Pupd15::RAW as u32) << pupd15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        pupd0: unsafe { Pupd0::conjure() },
                        pupd1: unsafe { Pupd1::conjure() },
                        pupd2: unsafe { Pupd2::conjure() },
                        pupd3: unsafe { Pupd3::conjure() },
                        pupd4: unsafe { Pupd4::conjure() },
                        pupd5: unsafe { Pupd5::conjure() },
                        pupd6: unsafe { Pupd6::conjure() },
                        pupd7: unsafe { Pupd7::conjure() },
                        pupd8: unsafe { Pupd8::conjure() },
                        pupd9: unsafe { Pupd9::conjure() },
                        pupd10: unsafe { Pupd10::conjure() },
                        pupd11: unsafe { Pupd11::conjure() },
                        pupd12: unsafe { Pupd12::conjure() },
                        pupd13: unsafe { Pupd13::conjure() },
                        pupd14: unsafe { Pupd14::conjure() },
                        pupd15: unsafe { Pupd15::conjure() },
                    }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn transition<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >(
                    self,
                ) -> Register<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >
                where
                    NewPupd0: pupd0::State,
                    NewPupd1: pupd1::State,
                    NewPupd2: pupd2::State,
                    NewPupd3: pupd3::State,
                    NewPupd4: pupd4::State,
                    NewPupd5: pupd5::State,
                    NewPupd6: pupd6::State,
                    NewPupd7: pupd7::State,
                    NewPupd8: pupd8::State,
                    NewPupd9: pupd9::State,
                    NewPupd10: pupd10::State,
                    NewPupd11: pupd11::State,
                    NewPupd12: pupd12::State,
                    NewPupd13: pupd13::State,
                    NewPupd14: pupd14::State,
                    NewPupd15: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd1<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    S,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd2<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    S,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd3<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    S,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd4<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    S,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd5<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    S,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd6<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    S,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd7<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    S,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd8<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    S,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd9<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    S,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd10<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    S,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd11<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    S,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd12<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    S,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd13<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    S,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd14<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    S,
                    Pupd15,
                >
                where
                    S: pupd14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd15<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    S,
                >
                where
                    S: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub const BASE_ADDR: u32 = 1207960576u32;
        pub struct Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub moder: Moder,
            pub otyper: Otyper,
            pub ospeedr: Ospeedr,
            pub pupdr: Pupdr,
        }
        pub type Reset = Block<
            moder::Reset,
            otyper::Reset,
            ospeedr::Reset,
            pupdr::Reset,
        >;
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn moder<R>(
                self,
                f: impl FnOnce(Moder) -> R,
            ) -> Block<R, Otyper, Ospeedr, Pupdr> {
                Block {
                    moder: f(self.moder),
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn otyper<R>(
                self,
                f: impl FnOnce(Otyper) -> R,
            ) -> Block<Moder, R, Ospeedr, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: f(self.otyper),
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn ospeedr<R>(
                self,
                f: impl FnOnce(Ospeedr) -> R,
            ) -> Block<Moder, Otyper, R, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: f(self.ospeedr),
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn pupdr<R>(
                self,
                f: impl FnOnce(Pupdr) -> R,
            ) -> Block<Moder, Otyper, Ospeedr, R> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: f(self.pupdr),
                }
            }
        }
    }
    mod gpioe {
        pub mod moder {
            pub mod mode0 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode1 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode0::OFFSET + super::mode0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode0::OFFSET + super::mode0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode2 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode1::OFFSET + super::mode1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode1::OFFSET + super::mode1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode3 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode2::OFFSET + super::mode2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode2::OFFSET + super::mode2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode4 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode3::OFFSET + super::mode3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode3::OFFSET + super::mode3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode5 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode4::OFFSET + super::mode4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode4::OFFSET + super::mode4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode6 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode5::OFFSET + super::mode5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode5::OFFSET + super::mode5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode7 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode6::OFFSET + super::mode6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode6::OFFSET + super::mode6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode8 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode7::OFFSET + super::mode7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode7::OFFSET + super::mode7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode9 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode8::OFFSET + super::mode8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode8::OFFSET + super::mode8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode10 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode9::OFFSET + super::mode9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode9::OFFSET + super::mode9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode11 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode10::OFFSET + super::mode10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode10::OFFSET + super::mode10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode12 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode11::OFFSET + super::mode11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode11::OFFSET + super::mode11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode13 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode12::OFFSET + super::mode12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode12::OFFSET + super::mode12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode14 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode13::OFFSET + super::mode13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode13::OFFSET + super::mode13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode15 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode14::OFFSET + super::mode14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode14::OFFSET + super::mode14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = 0 as u32;
            pub struct Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: Mode0,
                pub mode1: Mode1,
                pub mode2: Mode2,
                pub mode3: Mode3,
                pub mode4: Mode4,
                pub mode5: Mode5,
                pub mode6: Mode6,
                pub mode7: Mode7,
                pub mode8: Mode8,
                pub mode9: Mode9,
                pub mode10: Mode10,
                pub mode11: Mode11,
                pub mode12: Mode12,
                pub mode13: Mode13,
                pub mode14: Mode14,
                pub mode15: Mode15,
            }
            pub type Reset = Register<
                mode0::Reset,
                mode1::Reset,
                mode2::Reset,
                mode3::Reset,
                mode4::Reset,
                mode5::Reset,
                mode6::Reset,
                mode7::Reset,
                mode8::Reset,
                mode9::Reset,
                mode10::Reset,
                mode11::Reset,
                mode12::Reset,
                mode13::Reset,
                mode14::Reset,
                mode15::Reset,
            >;
            pub struct TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: core::marker::PhantomData<Mode0>,
                pub mode1: core::marker::PhantomData<Mode1>,
                pub mode2: core::marker::PhantomData<Mode2>,
                pub mode3: core::marker::PhantomData<Mode3>,
                pub mode4: core::marker::PhantomData<Mode4>,
                pub mode5: core::marker::PhantomData<Mode5>,
                pub mode6: core::marker::PhantomData<Mode6>,
                pub mode7: core::marker::PhantomData<Mode7>,
                pub mode8: core::marker::PhantomData<Mode8>,
                pub mode9: core::marker::PhantomData<Mode9>,
                pub mode10: core::marker::PhantomData<Mode10>,
                pub mode11: core::marker::PhantomData<Mode11>,
                pub mode12: core::marker::PhantomData<Mode12>,
                pub mode13: core::marker::PhantomData<Mode13>,
                pub mode14: core::marker::PhantomData<Mode14>,
                pub mode15: core::marker::PhantomData<Mode15>,
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        mode0: core::marker::PhantomData,
                        mode1: core::marker::PhantomData,
                        mode2: core::marker::PhantomData,
                        mode3: core::marker::PhantomData,
                        mode4: core::marker::PhantomData,
                        mode5: core::marker::PhantomData,
                        mode6: core::marker::PhantomData,
                        mode7: core::marker::PhantomData,
                        mode8: core::marker::PhantomData,
                        mode9: core::marker::PhantomData,
                        mode10: core::marker::PhantomData,
                        mode11: core::marker::PhantomData,
                        mode12: core::marker::PhantomData,
                        mode13: core::marker::PhantomData,
                        mode14: core::marker::PhantomData,
                        mode15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    let reg_value = ((Mode0::RAW as u32) << mode0::OFFSET)
                        | ((Mode1::RAW as u32) << mode1::OFFSET)
                        | ((Mode2::RAW as u32) << mode2::OFFSET)
                        | ((Mode3::RAW as u32) << mode3::OFFSET)
                        | ((Mode4::RAW as u32) << mode4::OFFSET)
                        | ((Mode5::RAW as u32) << mode5::OFFSET)
                        | ((Mode6::RAW as u32) << mode6::OFFSET)
                        | ((Mode7::RAW as u32) << mode7::OFFSET)
                        | ((Mode8::RAW as u32) << mode8::OFFSET)
                        | ((Mode9::RAW as u32) << mode9::OFFSET)
                        | ((Mode10::RAW as u32) << mode10::OFFSET)
                        | ((Mode11::RAW as u32) << mode11::OFFSET)
                        | ((Mode12::RAW as u32) << mode12::OFFSET)
                        | ((Mode13::RAW as u32) << mode13::OFFSET)
                        | ((Mode14::RAW as u32) << mode14::OFFSET)
                        | ((Mode15::RAW as u32) << mode15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        mode0: unsafe { Mode0::conjure() },
                        mode1: unsafe { Mode1::conjure() },
                        mode2: unsafe { Mode2::conjure() },
                        mode3: unsafe { Mode3::conjure() },
                        mode4: unsafe { Mode4::conjure() },
                        mode5: unsafe { Mode5::conjure() },
                        mode6: unsafe { Mode6::conjure() },
                        mode7: unsafe { Mode7::conjure() },
                        mode8: unsafe { Mode8::conjure() },
                        mode9: unsafe { Mode9::conjure() },
                        mode10: unsafe { Mode10::conjure() },
                        mode11: unsafe { Mode11::conjure() },
                        mode12: unsafe { Mode12::conjure() },
                        mode13: unsafe { Mode13::conjure() },
                        mode14: unsafe { Mode14::conjure() },
                        mode15: unsafe { Mode15::conjure() },
                    }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn transition<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >(
                    self,
                ) -> Register<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >
                where
                    NewMode0: mode0::State,
                    NewMode1: mode1::State,
                    NewMode2: mode2::State,
                    NewMode3: mode3::State,
                    NewMode4: mode4::State,
                    NewMode5: mode5::State,
                    NewMode6: mode6::State,
                    NewMode7: mode7::State,
                    NewMode8: mode8::State,
                    NewMode9: mode9::State,
                    NewMode10: mode10::State,
                    NewMode11: mode11::State,
                    NewMode12: mode12::State,
                    NewMode13: mode13::State,
                    NewMode14: mode14::State,
                    NewMode15: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode1<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    S,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode2<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    S,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode3<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    S,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode4<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    S,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode5<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    S,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode6<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    S,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode7<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    S,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode8<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    S,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode9<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    S,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode10<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    S,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode11<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    S,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode12<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    S,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode13<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    S,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode14<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    S,
                    Mode15,
                >
                where
                    S: mode14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode15<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    S,
                >
                where
                    S: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod otyper {
            pub mod ot0 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot1 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot0::OFFSET + super::ot0::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot0::OFFSET + super::ot0::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot2 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot1::OFFSET + super::ot1::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot1::OFFSET + super::ot1::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot3 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot2::OFFSET + super::ot2::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot2::OFFSET + super::ot2::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot4 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot3::OFFSET + super::ot3::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot3::OFFSET + super::ot3::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot5 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot4::OFFSET + super::ot4::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot4::OFFSET + super::ot4::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot6 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot5::OFFSET + super::ot5::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot5::OFFSET + super::ot5::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot7 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot6::OFFSET + super::ot6::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot6::OFFSET + super::ot6::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot8 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot7::OFFSET + super::ot7::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot7::OFFSET + super::ot7::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot9 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot8::OFFSET + super::ot8::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot8::OFFSET + super::ot8::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot10 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot9::OFFSET + super::ot9::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot9::OFFSET + super::ot9::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot11 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot10::OFFSET + super::ot10::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot10::OFFSET + super::ot10::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot12 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot11::OFFSET + super::ot11::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot11::OFFSET + super::ot11::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot13 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot12::OFFSET + super::ot12::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot12::OFFSET + super::ot12::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot14 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot13::OFFSET + super::ot13::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot13::OFFSET + super::ot13::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot15 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot14::OFFSET + super::ot14::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot14::OFFSET + super::ot14::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::moder::OFFSET + 32 as u32;
            pub struct Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: Ot0,
                pub ot1: Ot1,
                pub ot2: Ot2,
                pub ot3: Ot3,
                pub ot4: Ot4,
                pub ot5: Ot5,
                pub ot6: Ot6,
                pub ot7: Ot7,
                pub ot8: Ot8,
                pub ot9: Ot9,
                pub ot10: Ot10,
                pub ot11: Ot11,
                pub ot12: Ot12,
                pub ot13: Ot13,
                pub ot14: Ot14,
                pub ot15: Ot15,
            }
            pub type Reset = Register<
                ot0::Reset,
                ot1::Reset,
                ot2::Reset,
                ot3::Reset,
                ot4::Reset,
                ot5::Reset,
                ot6::Reset,
                ot7::Reset,
                ot8::Reset,
                ot9::Reset,
                ot10::Reset,
                ot11::Reset,
                ot12::Reset,
                ot13::Reset,
                ot14::Reset,
                ot15::Reset,
            >;
            pub struct TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: core::marker::PhantomData<Ot0>,
                pub ot1: core::marker::PhantomData<Ot1>,
                pub ot2: core::marker::PhantomData<Ot2>,
                pub ot3: core::marker::PhantomData<Ot3>,
                pub ot4: core::marker::PhantomData<Ot4>,
                pub ot5: core::marker::PhantomData<Ot5>,
                pub ot6: core::marker::PhantomData<Ot6>,
                pub ot7: core::marker::PhantomData<Ot7>,
                pub ot8: core::marker::PhantomData<Ot8>,
                pub ot9: core::marker::PhantomData<Ot9>,
                pub ot10: core::marker::PhantomData<Ot10>,
                pub ot11: core::marker::PhantomData<Ot11>,
                pub ot12: core::marker::PhantomData<Ot12>,
                pub ot13: core::marker::PhantomData<Ot13>,
                pub ot14: core::marker::PhantomData<Ot14>,
                pub ot15: core::marker::PhantomData<Ot15>,
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ot0: core::marker::PhantomData,
                        ot1: core::marker::PhantomData,
                        ot2: core::marker::PhantomData,
                        ot3: core::marker::PhantomData,
                        ot4: core::marker::PhantomData,
                        ot5: core::marker::PhantomData,
                        ot6: core::marker::PhantomData,
                        ot7: core::marker::PhantomData,
                        ot8: core::marker::PhantomData,
                        ot9: core::marker::PhantomData,
                        ot10: core::marker::PhantomData,
                        ot11: core::marker::PhantomData,
                        ot12: core::marker::PhantomData,
                        ot13: core::marker::PhantomData,
                        ot14: core::marker::PhantomData,
                        ot15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    let reg_value = ((Ot0::RAW as u32) << ot0::OFFSET)
                        | ((Ot1::RAW as u32) << ot1::OFFSET)
                        | ((Ot2::RAW as u32) << ot2::OFFSET)
                        | ((Ot3::RAW as u32) << ot3::OFFSET)
                        | ((Ot4::RAW as u32) << ot4::OFFSET)
                        | ((Ot5::RAW as u32) << ot5::OFFSET)
                        | ((Ot6::RAW as u32) << ot6::OFFSET)
                        | ((Ot7::RAW as u32) << ot7::OFFSET)
                        | ((Ot8::RAW as u32) << ot8::OFFSET)
                        | ((Ot9::RAW as u32) << ot9::OFFSET)
                        | ((Ot10::RAW as u32) << ot10::OFFSET)
                        | ((Ot11::RAW as u32) << ot11::OFFSET)
                        | ((Ot12::RAW as u32) << ot12::OFFSET)
                        | ((Ot13::RAW as u32) << ot13::OFFSET)
                        | ((Ot14::RAW as u32) << ot14::OFFSET)
                        | ((Ot15::RAW as u32) << ot15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ot0: unsafe { Ot0::conjure() },
                        ot1: unsafe { Ot1::conjure() },
                        ot2: unsafe { Ot2::conjure() },
                        ot3: unsafe { Ot3::conjure() },
                        ot4: unsafe { Ot4::conjure() },
                        ot5: unsafe { Ot5::conjure() },
                        ot6: unsafe { Ot6::conjure() },
                        ot7: unsafe { Ot7::conjure() },
                        ot8: unsafe { Ot8::conjure() },
                        ot9: unsafe { Ot9::conjure() },
                        ot10: unsafe { Ot10::conjure() },
                        ot11: unsafe { Ot11::conjure() },
                        ot12: unsafe { Ot12::conjure() },
                        ot13: unsafe { Ot13::conjure() },
                        ot14: unsafe { Ot14::conjure() },
                        ot15: unsafe { Ot15::conjure() },
                    }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn transition<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >(
                    self,
                ) -> Register<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >
                where
                    NewOt0: ot0::State,
                    NewOt1: ot1::State,
                    NewOt2: ot2::State,
                    NewOt3: ot3::State,
                    NewOt4: ot4::State,
                    NewOt5: ot5::State,
                    NewOt6: ot6::State,
                    NewOt7: ot7::State,
                    NewOt8: ot8::State,
                    NewOt9: ot9::State,
                    NewOt10: ot10::State,
                    NewOt11: ot11::State,
                    NewOt12: ot12::State,
                    NewOt13: ot13::State,
                    NewOt14: ot14::State,
                    NewOt15: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    S,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    S,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    S,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    S,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    S,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    S,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    S,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    S,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    S,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    S,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    S,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    S,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    S,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    S,
                    Ot15,
                >
                where
                    S: ot14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    S,
                >
                where
                    S: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod ospeedr {
            pub mod ospeed0 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed1 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed0::OFFSET + super::ospeed0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed0::OFFSET + super::ospeed0::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed2 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed1::OFFSET + super::ospeed1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed1::OFFSET + super::ospeed1::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed3 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed2::OFFSET + super::ospeed2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed2::OFFSET + super::ospeed2::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed4 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed3::OFFSET + super::ospeed3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed3::OFFSET + super::ospeed3::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed5 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed4::OFFSET + super::ospeed4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed4::OFFSET + super::ospeed4::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed6 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed5::OFFSET + super::ospeed5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed5::OFFSET + super::ospeed5::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed7 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed6::OFFSET + super::ospeed6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed6::OFFSET + super::ospeed6::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed8 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed7::OFFSET + super::ospeed7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed7::OFFSET + super::ospeed7::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed9 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed8::OFFSET + super::ospeed8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed8::OFFSET + super::ospeed8::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed10 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed9::OFFSET + super::ospeed9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed9::OFFSET + super::ospeed9::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed11 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed10::OFFSET + super::ospeed10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed10::OFFSET + super::ospeed10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed12 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed11::OFFSET + super::ospeed11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed11::OFFSET + super::ospeed11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed13 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed12::OFFSET + super::ospeed12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed12::OFFSET + super::ospeed12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed14 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed13::OFFSET + super::ospeed13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed13::OFFSET + super::ospeed13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed15 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed14::OFFSET + super::ospeed14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed14::OFFSET + super::ospeed14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::otyper::OFFSET + 32 as u32;
            pub struct Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: Ospeed0,
                pub ospeed1: Ospeed1,
                pub ospeed2: Ospeed2,
                pub ospeed3: Ospeed3,
                pub ospeed4: Ospeed4,
                pub ospeed5: Ospeed5,
                pub ospeed6: Ospeed6,
                pub ospeed7: Ospeed7,
                pub ospeed8: Ospeed8,
                pub ospeed9: Ospeed9,
                pub ospeed10: Ospeed10,
                pub ospeed11: Ospeed11,
                pub ospeed12: Ospeed12,
                pub ospeed13: Ospeed13,
                pub ospeed14: Ospeed14,
                pub ospeed15: Ospeed15,
            }
            pub type Reset = Register<
                ospeed0::Reset,
                ospeed1::Reset,
                ospeed2::Reset,
                ospeed3::Reset,
                ospeed4::Reset,
                ospeed5::Reset,
                ospeed6::Reset,
                ospeed7::Reset,
                ospeed8::Reset,
                ospeed9::Reset,
                ospeed10::Reset,
                ospeed11::Reset,
                ospeed12::Reset,
                ospeed13::Reset,
                ospeed14::Reset,
                ospeed15::Reset,
            >;
            pub struct TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: core::marker::PhantomData<Ospeed0>,
                pub ospeed1: core::marker::PhantomData<Ospeed1>,
                pub ospeed2: core::marker::PhantomData<Ospeed2>,
                pub ospeed3: core::marker::PhantomData<Ospeed3>,
                pub ospeed4: core::marker::PhantomData<Ospeed4>,
                pub ospeed5: core::marker::PhantomData<Ospeed5>,
                pub ospeed6: core::marker::PhantomData<Ospeed6>,
                pub ospeed7: core::marker::PhantomData<Ospeed7>,
                pub ospeed8: core::marker::PhantomData<Ospeed8>,
                pub ospeed9: core::marker::PhantomData<Ospeed9>,
                pub ospeed10: core::marker::PhantomData<Ospeed10>,
                pub ospeed11: core::marker::PhantomData<Ospeed11>,
                pub ospeed12: core::marker::PhantomData<Ospeed12>,
                pub ospeed13: core::marker::PhantomData<Ospeed13>,
                pub ospeed14: core::marker::PhantomData<Ospeed14>,
                pub ospeed15: core::marker::PhantomData<Ospeed15>,
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ospeed0: core::marker::PhantomData,
                        ospeed1: core::marker::PhantomData,
                        ospeed2: core::marker::PhantomData,
                        ospeed3: core::marker::PhantomData,
                        ospeed4: core::marker::PhantomData,
                        ospeed5: core::marker::PhantomData,
                        ospeed6: core::marker::PhantomData,
                        ospeed7: core::marker::PhantomData,
                        ospeed8: core::marker::PhantomData,
                        ospeed9: core::marker::PhantomData,
                        ospeed10: core::marker::PhantomData,
                        ospeed11: core::marker::PhantomData,
                        ospeed12: core::marker::PhantomData,
                        ospeed13: core::marker::PhantomData,
                        ospeed14: core::marker::PhantomData,
                        ospeed15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    let reg_value = ((Ospeed0::RAW as u32) << ospeed0::OFFSET)
                        | ((Ospeed1::RAW as u32) << ospeed1::OFFSET)
                        | ((Ospeed2::RAW as u32) << ospeed2::OFFSET)
                        | ((Ospeed3::RAW as u32) << ospeed3::OFFSET)
                        | ((Ospeed4::RAW as u32) << ospeed4::OFFSET)
                        | ((Ospeed5::RAW as u32) << ospeed5::OFFSET)
                        | ((Ospeed6::RAW as u32) << ospeed6::OFFSET)
                        | ((Ospeed7::RAW as u32) << ospeed7::OFFSET)
                        | ((Ospeed8::RAW as u32) << ospeed8::OFFSET)
                        | ((Ospeed9::RAW as u32) << ospeed9::OFFSET)
                        | ((Ospeed10::RAW as u32) << ospeed10::OFFSET)
                        | ((Ospeed11::RAW as u32) << ospeed11::OFFSET)
                        | ((Ospeed12::RAW as u32) << ospeed12::OFFSET)
                        | ((Ospeed13::RAW as u32) << ospeed13::OFFSET)
                        | ((Ospeed14::RAW as u32) << ospeed14::OFFSET)
                        | ((Ospeed15::RAW as u32) << ospeed15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ospeed0: unsafe { Ospeed0::conjure() },
                        ospeed1: unsafe { Ospeed1::conjure() },
                        ospeed2: unsafe { Ospeed2::conjure() },
                        ospeed3: unsafe { Ospeed3::conjure() },
                        ospeed4: unsafe { Ospeed4::conjure() },
                        ospeed5: unsafe { Ospeed5::conjure() },
                        ospeed6: unsafe { Ospeed6::conjure() },
                        ospeed7: unsafe { Ospeed7::conjure() },
                        ospeed8: unsafe { Ospeed8::conjure() },
                        ospeed9: unsafe { Ospeed9::conjure() },
                        ospeed10: unsafe { Ospeed10::conjure() },
                        ospeed11: unsafe { Ospeed11::conjure() },
                        ospeed12: unsafe { Ospeed12::conjure() },
                        ospeed13: unsafe { Ospeed13::conjure() },
                        ospeed14: unsafe { Ospeed14::conjure() },
                        ospeed15: unsafe { Ospeed15::conjure() },
                    }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn transition<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >(
                    self,
                ) -> Register<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >
                where
                    NewOspeed0: ospeed0::State,
                    NewOspeed1: ospeed1::State,
                    NewOspeed2: ospeed2::State,
                    NewOspeed3: ospeed3::State,
                    NewOspeed4: ospeed4::State,
                    NewOspeed5: ospeed5::State,
                    NewOspeed6: ospeed6::State,
                    NewOspeed7: ospeed7::State,
                    NewOspeed8: ospeed8::State,
                    NewOspeed9: ospeed9::State,
                    NewOspeed10: ospeed10::State,
                    NewOspeed11: ospeed11::State,
                    NewOspeed12: ospeed12::State,
                    NewOspeed13: ospeed13::State,
                    NewOspeed14: ospeed14::State,
                    NewOspeed15: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    S,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    S,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    S,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    S,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    S,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    S,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    S,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    S,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    S,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    S,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    S,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    S,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    S,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    S,
                    Ospeed15,
                >
                where
                    S: ospeed14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    S,
                >
                where
                    S: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod pupdr {
            pub mod pupd0 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd1 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd0::OFFSET + super::pupd0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd0::OFFSET + super::pupd0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd2 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd1::OFFSET + super::pupd1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd1::OFFSET + super::pupd1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd3 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd2::OFFSET + super::pupd2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd2::OFFSET + super::pupd2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd4 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd3::OFFSET + super::pupd3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd3::OFFSET + super::pupd3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd5 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd4::OFFSET + super::pupd4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd4::OFFSET + super::pupd4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd6 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd5::OFFSET + super::pupd5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd5::OFFSET + super::pupd5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd7 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd6::OFFSET + super::pupd6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd6::OFFSET + super::pupd6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd8 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd7::OFFSET + super::pupd7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd7::OFFSET + super::pupd7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd9 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd8::OFFSET + super::pupd8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd8::OFFSET + super::pupd8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd10 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd9::OFFSET + super::pupd9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd9::OFFSET + super::pupd9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd11 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd10::OFFSET + super::pupd10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd10::OFFSET + super::pupd10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd12 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd11::OFFSET + super::pupd11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd11::OFFSET + super::pupd11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd13 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd12::OFFSET + super::pupd12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd12::OFFSET + super::pupd12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd14 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd13::OFFSET + super::pupd13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd13::OFFSET + super::pupd13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd15 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd14::OFFSET + super::pupd14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd14::OFFSET + super::pupd14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::ospeedr::OFFSET + 32 as u32;
            pub struct Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: Pupd0,
                pub pupd1: Pupd1,
                pub pupd2: Pupd2,
                pub pupd3: Pupd3,
                pub pupd4: Pupd4,
                pub pupd5: Pupd5,
                pub pupd6: Pupd6,
                pub pupd7: Pupd7,
                pub pupd8: Pupd8,
                pub pupd9: Pupd9,
                pub pupd10: Pupd10,
                pub pupd11: Pupd11,
                pub pupd12: Pupd12,
                pub pupd13: Pupd13,
                pub pupd14: Pupd14,
                pub pupd15: Pupd15,
            }
            pub type Reset = Register<
                pupd0::Reset,
                pupd1::Reset,
                pupd2::Reset,
                pupd3::Reset,
                pupd4::Reset,
                pupd5::Reset,
                pupd6::Reset,
                pupd7::Reset,
                pupd8::Reset,
                pupd9::Reset,
                pupd10::Reset,
                pupd11::Reset,
                pupd12::Reset,
                pupd13::Reset,
                pupd14::Reset,
                pupd15::Reset,
            >;
            pub struct TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: core::marker::PhantomData<Pupd0>,
                pub pupd1: core::marker::PhantomData<Pupd1>,
                pub pupd2: core::marker::PhantomData<Pupd2>,
                pub pupd3: core::marker::PhantomData<Pupd3>,
                pub pupd4: core::marker::PhantomData<Pupd4>,
                pub pupd5: core::marker::PhantomData<Pupd5>,
                pub pupd6: core::marker::PhantomData<Pupd6>,
                pub pupd7: core::marker::PhantomData<Pupd7>,
                pub pupd8: core::marker::PhantomData<Pupd8>,
                pub pupd9: core::marker::PhantomData<Pupd9>,
                pub pupd10: core::marker::PhantomData<Pupd10>,
                pub pupd11: core::marker::PhantomData<Pupd11>,
                pub pupd12: core::marker::PhantomData<Pupd12>,
                pub pupd13: core::marker::PhantomData<Pupd13>,
                pub pupd14: core::marker::PhantomData<Pupd14>,
                pub pupd15: core::marker::PhantomData<Pupd15>,
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        pupd0: core::marker::PhantomData,
                        pupd1: core::marker::PhantomData,
                        pupd2: core::marker::PhantomData,
                        pupd3: core::marker::PhantomData,
                        pupd4: core::marker::PhantomData,
                        pupd5: core::marker::PhantomData,
                        pupd6: core::marker::PhantomData,
                        pupd7: core::marker::PhantomData,
                        pupd8: core::marker::PhantomData,
                        pupd9: core::marker::PhantomData,
                        pupd10: core::marker::PhantomData,
                        pupd11: core::marker::PhantomData,
                        pupd12: core::marker::PhantomData,
                        pupd13: core::marker::PhantomData,
                        pupd14: core::marker::PhantomData,
                        pupd15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    let reg_value = ((Pupd0::RAW as u32) << pupd0::OFFSET)
                        | ((Pupd1::RAW as u32) << pupd1::OFFSET)
                        | ((Pupd2::RAW as u32) << pupd2::OFFSET)
                        | ((Pupd3::RAW as u32) << pupd3::OFFSET)
                        | ((Pupd4::RAW as u32) << pupd4::OFFSET)
                        | ((Pupd5::RAW as u32) << pupd5::OFFSET)
                        | ((Pupd6::RAW as u32) << pupd6::OFFSET)
                        | ((Pupd7::RAW as u32) << pupd7::OFFSET)
                        | ((Pupd8::RAW as u32) << pupd8::OFFSET)
                        | ((Pupd9::RAW as u32) << pupd9::OFFSET)
                        | ((Pupd10::RAW as u32) << pupd10::OFFSET)
                        | ((Pupd11::RAW as u32) << pupd11::OFFSET)
                        | ((Pupd12::RAW as u32) << pupd12::OFFSET)
                        | ((Pupd13::RAW as u32) << pupd13::OFFSET)
                        | ((Pupd14::RAW as u32) << pupd14::OFFSET)
                        | ((Pupd15::RAW as u32) << pupd15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        pupd0: unsafe { Pupd0::conjure() },
                        pupd1: unsafe { Pupd1::conjure() },
                        pupd2: unsafe { Pupd2::conjure() },
                        pupd3: unsafe { Pupd3::conjure() },
                        pupd4: unsafe { Pupd4::conjure() },
                        pupd5: unsafe { Pupd5::conjure() },
                        pupd6: unsafe { Pupd6::conjure() },
                        pupd7: unsafe { Pupd7::conjure() },
                        pupd8: unsafe { Pupd8::conjure() },
                        pupd9: unsafe { Pupd9::conjure() },
                        pupd10: unsafe { Pupd10::conjure() },
                        pupd11: unsafe { Pupd11::conjure() },
                        pupd12: unsafe { Pupd12::conjure() },
                        pupd13: unsafe { Pupd13::conjure() },
                        pupd14: unsafe { Pupd14::conjure() },
                        pupd15: unsafe { Pupd15::conjure() },
                    }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn transition<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >(
                    self,
                ) -> Register<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >
                where
                    NewPupd0: pupd0::State,
                    NewPupd1: pupd1::State,
                    NewPupd2: pupd2::State,
                    NewPupd3: pupd3::State,
                    NewPupd4: pupd4::State,
                    NewPupd5: pupd5::State,
                    NewPupd6: pupd6::State,
                    NewPupd7: pupd7::State,
                    NewPupd8: pupd8::State,
                    NewPupd9: pupd9::State,
                    NewPupd10: pupd10::State,
                    NewPupd11: pupd11::State,
                    NewPupd12: pupd12::State,
                    NewPupd13: pupd13::State,
                    NewPupd14: pupd14::State,
                    NewPupd15: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd1<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    S,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd2<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    S,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd3<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    S,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd4<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    S,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd5<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    S,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd6<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    S,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd7<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    S,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd8<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    S,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd9<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    S,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd10<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    S,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd11<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    S,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd12<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    S,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd13<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    S,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd14<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    S,
                    Pupd15,
                >
                where
                    S: pupd14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd15<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    S,
                >
                where
                    S: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub const BASE_ADDR: u32 = 1207960576u32;
        pub struct Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub moder: Moder,
            pub otyper: Otyper,
            pub ospeedr: Ospeedr,
            pub pupdr: Pupdr,
        }
        pub type Reset = Block<
            moder::Reset,
            otyper::Reset,
            ospeedr::Reset,
            pupdr::Reset,
        >;
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn moder<R>(
                self,
                f: impl FnOnce(Moder) -> R,
            ) -> Block<R, Otyper, Ospeedr, Pupdr> {
                Block {
                    moder: f(self.moder),
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn otyper<R>(
                self,
                f: impl FnOnce(Otyper) -> R,
            ) -> Block<Moder, R, Ospeedr, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: f(self.otyper),
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn ospeedr<R>(
                self,
                f: impl FnOnce(Ospeedr) -> R,
            ) -> Block<Moder, Otyper, R, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: f(self.ospeedr),
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn pupdr<R>(
                self,
                f: impl FnOnce(Pupdr) -> R,
            ) -> Block<Moder, Otyper, Ospeedr, R> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: f(self.pupdr),
                }
            }
        }
    }
    mod gpiof {
        pub mod moder {
            pub mod mode0 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode1 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode0::OFFSET + super::mode0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode0::OFFSET + super::mode0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode2 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode1::OFFSET + super::mode1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode1::OFFSET + super::mode1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode3 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode2::OFFSET + super::mode2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode2::OFFSET + super::mode2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode4 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode3::OFFSET + super::mode3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode3::OFFSET + super::mode3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode5 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode4::OFFSET + super::mode4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode4::OFFSET + super::mode4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode6 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode5::OFFSET + super::mode5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode5::OFFSET + super::mode5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode7 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode6::OFFSET + super::mode6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode6::OFFSET + super::mode6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode8 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode7::OFFSET + super::mode7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode7::OFFSET + super::mode7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode9 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode8::OFFSET + super::mode8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode8::OFFSET + super::mode8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode10 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode9::OFFSET + super::mode9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode9::OFFSET + super::mode9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode11 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode10::OFFSET + super::mode10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode10::OFFSET + super::mode10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode12 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode11::OFFSET + super::mode11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode11::OFFSET + super::mode11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode13 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode12::OFFSET + super::mode12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode12::OFFSET + super::mode12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode14 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode13::OFFSET + super::mode13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode13::OFFSET + super::mode13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode15 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode14::OFFSET + super::mode14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode14::OFFSET + super::mode14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = 0 as u32;
            pub struct Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: Mode0,
                pub mode1: Mode1,
                pub mode2: Mode2,
                pub mode3: Mode3,
                pub mode4: Mode4,
                pub mode5: Mode5,
                pub mode6: Mode6,
                pub mode7: Mode7,
                pub mode8: Mode8,
                pub mode9: Mode9,
                pub mode10: Mode10,
                pub mode11: Mode11,
                pub mode12: Mode12,
                pub mode13: Mode13,
                pub mode14: Mode14,
                pub mode15: Mode15,
            }
            pub type Reset = Register<
                mode0::Reset,
                mode1::Reset,
                mode2::Reset,
                mode3::Reset,
                mode4::Reset,
                mode5::Reset,
                mode6::Reset,
                mode7::Reset,
                mode8::Reset,
                mode9::Reset,
                mode10::Reset,
                mode11::Reset,
                mode12::Reset,
                mode13::Reset,
                mode14::Reset,
                mode15::Reset,
            >;
            pub struct TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: core::marker::PhantomData<Mode0>,
                pub mode1: core::marker::PhantomData<Mode1>,
                pub mode2: core::marker::PhantomData<Mode2>,
                pub mode3: core::marker::PhantomData<Mode3>,
                pub mode4: core::marker::PhantomData<Mode4>,
                pub mode5: core::marker::PhantomData<Mode5>,
                pub mode6: core::marker::PhantomData<Mode6>,
                pub mode7: core::marker::PhantomData<Mode7>,
                pub mode8: core::marker::PhantomData<Mode8>,
                pub mode9: core::marker::PhantomData<Mode9>,
                pub mode10: core::marker::PhantomData<Mode10>,
                pub mode11: core::marker::PhantomData<Mode11>,
                pub mode12: core::marker::PhantomData<Mode12>,
                pub mode13: core::marker::PhantomData<Mode13>,
                pub mode14: core::marker::PhantomData<Mode14>,
                pub mode15: core::marker::PhantomData<Mode15>,
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        mode0: core::marker::PhantomData,
                        mode1: core::marker::PhantomData,
                        mode2: core::marker::PhantomData,
                        mode3: core::marker::PhantomData,
                        mode4: core::marker::PhantomData,
                        mode5: core::marker::PhantomData,
                        mode6: core::marker::PhantomData,
                        mode7: core::marker::PhantomData,
                        mode8: core::marker::PhantomData,
                        mode9: core::marker::PhantomData,
                        mode10: core::marker::PhantomData,
                        mode11: core::marker::PhantomData,
                        mode12: core::marker::PhantomData,
                        mode13: core::marker::PhantomData,
                        mode14: core::marker::PhantomData,
                        mode15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    let reg_value = ((Mode0::RAW as u32) << mode0::OFFSET)
                        | ((Mode1::RAW as u32) << mode1::OFFSET)
                        | ((Mode2::RAW as u32) << mode2::OFFSET)
                        | ((Mode3::RAW as u32) << mode3::OFFSET)
                        | ((Mode4::RAW as u32) << mode4::OFFSET)
                        | ((Mode5::RAW as u32) << mode5::OFFSET)
                        | ((Mode6::RAW as u32) << mode6::OFFSET)
                        | ((Mode7::RAW as u32) << mode7::OFFSET)
                        | ((Mode8::RAW as u32) << mode8::OFFSET)
                        | ((Mode9::RAW as u32) << mode9::OFFSET)
                        | ((Mode10::RAW as u32) << mode10::OFFSET)
                        | ((Mode11::RAW as u32) << mode11::OFFSET)
                        | ((Mode12::RAW as u32) << mode12::OFFSET)
                        | ((Mode13::RAW as u32) << mode13::OFFSET)
                        | ((Mode14::RAW as u32) << mode14::OFFSET)
                        | ((Mode15::RAW as u32) << mode15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        mode0: unsafe { Mode0::conjure() },
                        mode1: unsafe { Mode1::conjure() },
                        mode2: unsafe { Mode2::conjure() },
                        mode3: unsafe { Mode3::conjure() },
                        mode4: unsafe { Mode4::conjure() },
                        mode5: unsafe { Mode5::conjure() },
                        mode6: unsafe { Mode6::conjure() },
                        mode7: unsafe { Mode7::conjure() },
                        mode8: unsafe { Mode8::conjure() },
                        mode9: unsafe { Mode9::conjure() },
                        mode10: unsafe { Mode10::conjure() },
                        mode11: unsafe { Mode11::conjure() },
                        mode12: unsafe { Mode12::conjure() },
                        mode13: unsafe { Mode13::conjure() },
                        mode14: unsafe { Mode14::conjure() },
                        mode15: unsafe { Mode15::conjure() },
                    }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn transition<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >(
                    self,
                ) -> Register<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >
                where
                    NewMode0: mode0::State,
                    NewMode1: mode1::State,
                    NewMode2: mode2::State,
                    NewMode3: mode3::State,
                    NewMode4: mode4::State,
                    NewMode5: mode5::State,
                    NewMode6: mode6::State,
                    NewMode7: mode7::State,
                    NewMode8: mode8::State,
                    NewMode9: mode9::State,
                    NewMode10: mode10::State,
                    NewMode11: mode11::State,
                    NewMode12: mode12::State,
                    NewMode13: mode13::State,
                    NewMode14: mode14::State,
                    NewMode15: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode1<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    S,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode2<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    S,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode3<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    S,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode4<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    S,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode5<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    S,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode6<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    S,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode7<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    S,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode8<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    S,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode9<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    S,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode10<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    S,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode11<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    S,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode12<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    S,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode13<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    S,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode14<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    S,
                    Mode15,
                >
                where
                    S: mode14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode15<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    S,
                >
                where
                    S: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod otyper {
            pub mod ot0 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot1 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot0::OFFSET + super::ot0::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot0::OFFSET + super::ot0::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot2 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot1::OFFSET + super::ot1::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot1::OFFSET + super::ot1::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot3 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot2::OFFSET + super::ot2::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot2::OFFSET + super::ot2::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot4 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot3::OFFSET + super::ot3::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot3::OFFSET + super::ot3::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot5 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot4::OFFSET + super::ot4::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot4::OFFSET + super::ot4::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot6 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot5::OFFSET + super::ot5::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot5::OFFSET + super::ot5::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot7 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot6::OFFSET + super::ot6::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot6::OFFSET + super::ot6::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot8 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot7::OFFSET + super::ot7::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot7::OFFSET + super::ot7::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot9 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot8::OFFSET + super::ot8::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot8::OFFSET + super::ot8::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot10 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot9::OFFSET + super::ot9::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot9::OFFSET + super::ot9::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot11 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot10::OFFSET + super::ot10::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot10::OFFSET + super::ot10::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot12 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot11::OFFSET + super::ot11::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot11::OFFSET + super::ot11::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot13 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot12::OFFSET + super::ot12::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot12::OFFSET + super::ot12::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot14 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot13::OFFSET + super::ot13::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot13::OFFSET + super::ot13::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot15 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot14::OFFSET + super::ot14::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot14::OFFSET + super::ot14::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::moder::OFFSET + 32 as u32;
            pub struct Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: Ot0,
                pub ot1: Ot1,
                pub ot2: Ot2,
                pub ot3: Ot3,
                pub ot4: Ot4,
                pub ot5: Ot5,
                pub ot6: Ot6,
                pub ot7: Ot7,
                pub ot8: Ot8,
                pub ot9: Ot9,
                pub ot10: Ot10,
                pub ot11: Ot11,
                pub ot12: Ot12,
                pub ot13: Ot13,
                pub ot14: Ot14,
                pub ot15: Ot15,
            }
            pub type Reset = Register<
                ot0::Reset,
                ot1::Reset,
                ot2::Reset,
                ot3::Reset,
                ot4::Reset,
                ot5::Reset,
                ot6::Reset,
                ot7::Reset,
                ot8::Reset,
                ot9::Reset,
                ot10::Reset,
                ot11::Reset,
                ot12::Reset,
                ot13::Reset,
                ot14::Reset,
                ot15::Reset,
            >;
            pub struct TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: core::marker::PhantomData<Ot0>,
                pub ot1: core::marker::PhantomData<Ot1>,
                pub ot2: core::marker::PhantomData<Ot2>,
                pub ot3: core::marker::PhantomData<Ot3>,
                pub ot4: core::marker::PhantomData<Ot4>,
                pub ot5: core::marker::PhantomData<Ot5>,
                pub ot6: core::marker::PhantomData<Ot6>,
                pub ot7: core::marker::PhantomData<Ot7>,
                pub ot8: core::marker::PhantomData<Ot8>,
                pub ot9: core::marker::PhantomData<Ot9>,
                pub ot10: core::marker::PhantomData<Ot10>,
                pub ot11: core::marker::PhantomData<Ot11>,
                pub ot12: core::marker::PhantomData<Ot12>,
                pub ot13: core::marker::PhantomData<Ot13>,
                pub ot14: core::marker::PhantomData<Ot14>,
                pub ot15: core::marker::PhantomData<Ot15>,
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ot0: core::marker::PhantomData,
                        ot1: core::marker::PhantomData,
                        ot2: core::marker::PhantomData,
                        ot3: core::marker::PhantomData,
                        ot4: core::marker::PhantomData,
                        ot5: core::marker::PhantomData,
                        ot6: core::marker::PhantomData,
                        ot7: core::marker::PhantomData,
                        ot8: core::marker::PhantomData,
                        ot9: core::marker::PhantomData,
                        ot10: core::marker::PhantomData,
                        ot11: core::marker::PhantomData,
                        ot12: core::marker::PhantomData,
                        ot13: core::marker::PhantomData,
                        ot14: core::marker::PhantomData,
                        ot15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    let reg_value = ((Ot0::RAW as u32) << ot0::OFFSET)
                        | ((Ot1::RAW as u32) << ot1::OFFSET)
                        | ((Ot2::RAW as u32) << ot2::OFFSET)
                        | ((Ot3::RAW as u32) << ot3::OFFSET)
                        | ((Ot4::RAW as u32) << ot4::OFFSET)
                        | ((Ot5::RAW as u32) << ot5::OFFSET)
                        | ((Ot6::RAW as u32) << ot6::OFFSET)
                        | ((Ot7::RAW as u32) << ot7::OFFSET)
                        | ((Ot8::RAW as u32) << ot8::OFFSET)
                        | ((Ot9::RAW as u32) << ot9::OFFSET)
                        | ((Ot10::RAW as u32) << ot10::OFFSET)
                        | ((Ot11::RAW as u32) << ot11::OFFSET)
                        | ((Ot12::RAW as u32) << ot12::OFFSET)
                        | ((Ot13::RAW as u32) << ot13::OFFSET)
                        | ((Ot14::RAW as u32) << ot14::OFFSET)
                        | ((Ot15::RAW as u32) << ot15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ot0: unsafe { Ot0::conjure() },
                        ot1: unsafe { Ot1::conjure() },
                        ot2: unsafe { Ot2::conjure() },
                        ot3: unsafe { Ot3::conjure() },
                        ot4: unsafe { Ot4::conjure() },
                        ot5: unsafe { Ot5::conjure() },
                        ot6: unsafe { Ot6::conjure() },
                        ot7: unsafe { Ot7::conjure() },
                        ot8: unsafe { Ot8::conjure() },
                        ot9: unsafe { Ot9::conjure() },
                        ot10: unsafe { Ot10::conjure() },
                        ot11: unsafe { Ot11::conjure() },
                        ot12: unsafe { Ot12::conjure() },
                        ot13: unsafe { Ot13::conjure() },
                        ot14: unsafe { Ot14::conjure() },
                        ot15: unsafe { Ot15::conjure() },
                    }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn transition<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >(
                    self,
                ) -> Register<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >
                where
                    NewOt0: ot0::State,
                    NewOt1: ot1::State,
                    NewOt2: ot2::State,
                    NewOt3: ot3::State,
                    NewOt4: ot4::State,
                    NewOt5: ot5::State,
                    NewOt6: ot6::State,
                    NewOt7: ot7::State,
                    NewOt8: ot8::State,
                    NewOt9: ot9::State,
                    NewOt10: ot10::State,
                    NewOt11: ot11::State,
                    NewOt12: ot12::State,
                    NewOt13: ot13::State,
                    NewOt14: ot14::State,
                    NewOt15: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    S,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    S,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    S,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    S,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    S,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    S,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    S,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    S,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    S,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    S,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    S,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    S,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    S,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    S,
                    Ot15,
                >
                where
                    S: ot14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    S,
                >
                where
                    S: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod ospeedr {
            pub mod ospeed0 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed1 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed0::OFFSET + super::ospeed0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed0::OFFSET + super::ospeed0::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed2 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed1::OFFSET + super::ospeed1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed1::OFFSET + super::ospeed1::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed3 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed2::OFFSET + super::ospeed2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed2::OFFSET + super::ospeed2::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed4 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed3::OFFSET + super::ospeed3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed3::OFFSET + super::ospeed3::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed5 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed4::OFFSET + super::ospeed4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed4::OFFSET + super::ospeed4::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed6 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed5::OFFSET + super::ospeed5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed5::OFFSET + super::ospeed5::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed7 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed6::OFFSET + super::ospeed6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed6::OFFSET + super::ospeed6::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed8 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed7::OFFSET + super::ospeed7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed7::OFFSET + super::ospeed7::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed9 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed8::OFFSET + super::ospeed8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed8::OFFSET + super::ospeed8::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed10 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed9::OFFSET + super::ospeed9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed9::OFFSET + super::ospeed9::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed11 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed10::OFFSET + super::ospeed10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed10::OFFSET + super::ospeed10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed12 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed11::OFFSET + super::ospeed11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed11::OFFSET + super::ospeed11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed13 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed12::OFFSET + super::ospeed12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed12::OFFSET + super::ospeed12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed14 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed13::OFFSET + super::ospeed13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed13::OFFSET + super::ospeed13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed15 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed14::OFFSET + super::ospeed14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed14::OFFSET + super::ospeed14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::otyper::OFFSET + 32 as u32;
            pub struct Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: Ospeed0,
                pub ospeed1: Ospeed1,
                pub ospeed2: Ospeed2,
                pub ospeed3: Ospeed3,
                pub ospeed4: Ospeed4,
                pub ospeed5: Ospeed5,
                pub ospeed6: Ospeed6,
                pub ospeed7: Ospeed7,
                pub ospeed8: Ospeed8,
                pub ospeed9: Ospeed9,
                pub ospeed10: Ospeed10,
                pub ospeed11: Ospeed11,
                pub ospeed12: Ospeed12,
                pub ospeed13: Ospeed13,
                pub ospeed14: Ospeed14,
                pub ospeed15: Ospeed15,
            }
            pub type Reset = Register<
                ospeed0::Reset,
                ospeed1::Reset,
                ospeed2::Reset,
                ospeed3::Reset,
                ospeed4::Reset,
                ospeed5::Reset,
                ospeed6::Reset,
                ospeed7::Reset,
                ospeed8::Reset,
                ospeed9::Reset,
                ospeed10::Reset,
                ospeed11::Reset,
                ospeed12::Reset,
                ospeed13::Reset,
                ospeed14::Reset,
                ospeed15::Reset,
            >;
            pub struct TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: core::marker::PhantomData<Ospeed0>,
                pub ospeed1: core::marker::PhantomData<Ospeed1>,
                pub ospeed2: core::marker::PhantomData<Ospeed2>,
                pub ospeed3: core::marker::PhantomData<Ospeed3>,
                pub ospeed4: core::marker::PhantomData<Ospeed4>,
                pub ospeed5: core::marker::PhantomData<Ospeed5>,
                pub ospeed6: core::marker::PhantomData<Ospeed6>,
                pub ospeed7: core::marker::PhantomData<Ospeed7>,
                pub ospeed8: core::marker::PhantomData<Ospeed8>,
                pub ospeed9: core::marker::PhantomData<Ospeed9>,
                pub ospeed10: core::marker::PhantomData<Ospeed10>,
                pub ospeed11: core::marker::PhantomData<Ospeed11>,
                pub ospeed12: core::marker::PhantomData<Ospeed12>,
                pub ospeed13: core::marker::PhantomData<Ospeed13>,
                pub ospeed14: core::marker::PhantomData<Ospeed14>,
                pub ospeed15: core::marker::PhantomData<Ospeed15>,
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ospeed0: core::marker::PhantomData,
                        ospeed1: core::marker::PhantomData,
                        ospeed2: core::marker::PhantomData,
                        ospeed3: core::marker::PhantomData,
                        ospeed4: core::marker::PhantomData,
                        ospeed5: core::marker::PhantomData,
                        ospeed6: core::marker::PhantomData,
                        ospeed7: core::marker::PhantomData,
                        ospeed8: core::marker::PhantomData,
                        ospeed9: core::marker::PhantomData,
                        ospeed10: core::marker::PhantomData,
                        ospeed11: core::marker::PhantomData,
                        ospeed12: core::marker::PhantomData,
                        ospeed13: core::marker::PhantomData,
                        ospeed14: core::marker::PhantomData,
                        ospeed15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    let reg_value = ((Ospeed0::RAW as u32) << ospeed0::OFFSET)
                        | ((Ospeed1::RAW as u32) << ospeed1::OFFSET)
                        | ((Ospeed2::RAW as u32) << ospeed2::OFFSET)
                        | ((Ospeed3::RAW as u32) << ospeed3::OFFSET)
                        | ((Ospeed4::RAW as u32) << ospeed4::OFFSET)
                        | ((Ospeed5::RAW as u32) << ospeed5::OFFSET)
                        | ((Ospeed6::RAW as u32) << ospeed6::OFFSET)
                        | ((Ospeed7::RAW as u32) << ospeed7::OFFSET)
                        | ((Ospeed8::RAW as u32) << ospeed8::OFFSET)
                        | ((Ospeed9::RAW as u32) << ospeed9::OFFSET)
                        | ((Ospeed10::RAW as u32) << ospeed10::OFFSET)
                        | ((Ospeed11::RAW as u32) << ospeed11::OFFSET)
                        | ((Ospeed12::RAW as u32) << ospeed12::OFFSET)
                        | ((Ospeed13::RAW as u32) << ospeed13::OFFSET)
                        | ((Ospeed14::RAW as u32) << ospeed14::OFFSET)
                        | ((Ospeed15::RAW as u32) << ospeed15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ospeed0: unsafe { Ospeed0::conjure() },
                        ospeed1: unsafe { Ospeed1::conjure() },
                        ospeed2: unsafe { Ospeed2::conjure() },
                        ospeed3: unsafe { Ospeed3::conjure() },
                        ospeed4: unsafe { Ospeed4::conjure() },
                        ospeed5: unsafe { Ospeed5::conjure() },
                        ospeed6: unsafe { Ospeed6::conjure() },
                        ospeed7: unsafe { Ospeed7::conjure() },
                        ospeed8: unsafe { Ospeed8::conjure() },
                        ospeed9: unsafe { Ospeed9::conjure() },
                        ospeed10: unsafe { Ospeed10::conjure() },
                        ospeed11: unsafe { Ospeed11::conjure() },
                        ospeed12: unsafe { Ospeed12::conjure() },
                        ospeed13: unsafe { Ospeed13::conjure() },
                        ospeed14: unsafe { Ospeed14::conjure() },
                        ospeed15: unsafe { Ospeed15::conjure() },
                    }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn transition<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >(
                    self,
                ) -> Register<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >
                where
                    NewOspeed0: ospeed0::State,
                    NewOspeed1: ospeed1::State,
                    NewOspeed2: ospeed2::State,
                    NewOspeed3: ospeed3::State,
                    NewOspeed4: ospeed4::State,
                    NewOspeed5: ospeed5::State,
                    NewOspeed6: ospeed6::State,
                    NewOspeed7: ospeed7::State,
                    NewOspeed8: ospeed8::State,
                    NewOspeed9: ospeed9::State,
                    NewOspeed10: ospeed10::State,
                    NewOspeed11: ospeed11::State,
                    NewOspeed12: ospeed12::State,
                    NewOspeed13: ospeed13::State,
                    NewOspeed14: ospeed14::State,
                    NewOspeed15: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    S,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    S,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    S,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    S,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    S,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    S,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    S,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    S,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    S,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    S,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    S,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    S,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    S,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    S,
                    Ospeed15,
                >
                where
                    S: ospeed14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    S,
                >
                where
                    S: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod pupdr {
            pub mod pupd0 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd1 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd0::OFFSET + super::pupd0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd0::OFFSET + super::pupd0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd2 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd1::OFFSET + super::pupd1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd1::OFFSET + super::pupd1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd3 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd2::OFFSET + super::pupd2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd2::OFFSET + super::pupd2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd4 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd3::OFFSET + super::pupd3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd3::OFFSET + super::pupd3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd5 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd4::OFFSET + super::pupd4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd4::OFFSET + super::pupd4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd6 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd5::OFFSET + super::pupd5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd5::OFFSET + super::pupd5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd7 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd6::OFFSET + super::pupd6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd6::OFFSET + super::pupd6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd8 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd7::OFFSET + super::pupd7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd7::OFFSET + super::pupd7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd9 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd8::OFFSET + super::pupd8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd8::OFFSET + super::pupd8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd10 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd9::OFFSET + super::pupd9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd9::OFFSET + super::pupd9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd11 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd10::OFFSET + super::pupd10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd10::OFFSET + super::pupd10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd12 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd11::OFFSET + super::pupd11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd11::OFFSET + super::pupd11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd13 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd12::OFFSET + super::pupd12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd12::OFFSET + super::pupd12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd14 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd13::OFFSET + super::pupd13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd13::OFFSET + super::pupd13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd15 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd14::OFFSET + super::pupd14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd14::OFFSET + super::pupd14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::ospeedr::OFFSET + 32 as u32;
            pub struct Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: Pupd0,
                pub pupd1: Pupd1,
                pub pupd2: Pupd2,
                pub pupd3: Pupd3,
                pub pupd4: Pupd4,
                pub pupd5: Pupd5,
                pub pupd6: Pupd6,
                pub pupd7: Pupd7,
                pub pupd8: Pupd8,
                pub pupd9: Pupd9,
                pub pupd10: Pupd10,
                pub pupd11: Pupd11,
                pub pupd12: Pupd12,
                pub pupd13: Pupd13,
                pub pupd14: Pupd14,
                pub pupd15: Pupd15,
            }
            pub type Reset = Register<
                pupd0::Reset,
                pupd1::Reset,
                pupd2::Reset,
                pupd3::Reset,
                pupd4::Reset,
                pupd5::Reset,
                pupd6::Reset,
                pupd7::Reset,
                pupd8::Reset,
                pupd9::Reset,
                pupd10::Reset,
                pupd11::Reset,
                pupd12::Reset,
                pupd13::Reset,
                pupd14::Reset,
                pupd15::Reset,
            >;
            pub struct TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: core::marker::PhantomData<Pupd0>,
                pub pupd1: core::marker::PhantomData<Pupd1>,
                pub pupd2: core::marker::PhantomData<Pupd2>,
                pub pupd3: core::marker::PhantomData<Pupd3>,
                pub pupd4: core::marker::PhantomData<Pupd4>,
                pub pupd5: core::marker::PhantomData<Pupd5>,
                pub pupd6: core::marker::PhantomData<Pupd6>,
                pub pupd7: core::marker::PhantomData<Pupd7>,
                pub pupd8: core::marker::PhantomData<Pupd8>,
                pub pupd9: core::marker::PhantomData<Pupd9>,
                pub pupd10: core::marker::PhantomData<Pupd10>,
                pub pupd11: core::marker::PhantomData<Pupd11>,
                pub pupd12: core::marker::PhantomData<Pupd12>,
                pub pupd13: core::marker::PhantomData<Pupd13>,
                pub pupd14: core::marker::PhantomData<Pupd14>,
                pub pupd15: core::marker::PhantomData<Pupd15>,
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        pupd0: core::marker::PhantomData,
                        pupd1: core::marker::PhantomData,
                        pupd2: core::marker::PhantomData,
                        pupd3: core::marker::PhantomData,
                        pupd4: core::marker::PhantomData,
                        pupd5: core::marker::PhantomData,
                        pupd6: core::marker::PhantomData,
                        pupd7: core::marker::PhantomData,
                        pupd8: core::marker::PhantomData,
                        pupd9: core::marker::PhantomData,
                        pupd10: core::marker::PhantomData,
                        pupd11: core::marker::PhantomData,
                        pupd12: core::marker::PhantomData,
                        pupd13: core::marker::PhantomData,
                        pupd14: core::marker::PhantomData,
                        pupd15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    let reg_value = ((Pupd0::RAW as u32) << pupd0::OFFSET)
                        | ((Pupd1::RAW as u32) << pupd1::OFFSET)
                        | ((Pupd2::RAW as u32) << pupd2::OFFSET)
                        | ((Pupd3::RAW as u32) << pupd3::OFFSET)
                        | ((Pupd4::RAW as u32) << pupd4::OFFSET)
                        | ((Pupd5::RAW as u32) << pupd5::OFFSET)
                        | ((Pupd6::RAW as u32) << pupd6::OFFSET)
                        | ((Pupd7::RAW as u32) << pupd7::OFFSET)
                        | ((Pupd8::RAW as u32) << pupd8::OFFSET)
                        | ((Pupd9::RAW as u32) << pupd9::OFFSET)
                        | ((Pupd10::RAW as u32) << pupd10::OFFSET)
                        | ((Pupd11::RAW as u32) << pupd11::OFFSET)
                        | ((Pupd12::RAW as u32) << pupd12::OFFSET)
                        | ((Pupd13::RAW as u32) << pupd13::OFFSET)
                        | ((Pupd14::RAW as u32) << pupd14::OFFSET)
                        | ((Pupd15::RAW as u32) << pupd15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        pupd0: unsafe { Pupd0::conjure() },
                        pupd1: unsafe { Pupd1::conjure() },
                        pupd2: unsafe { Pupd2::conjure() },
                        pupd3: unsafe { Pupd3::conjure() },
                        pupd4: unsafe { Pupd4::conjure() },
                        pupd5: unsafe { Pupd5::conjure() },
                        pupd6: unsafe { Pupd6::conjure() },
                        pupd7: unsafe { Pupd7::conjure() },
                        pupd8: unsafe { Pupd8::conjure() },
                        pupd9: unsafe { Pupd9::conjure() },
                        pupd10: unsafe { Pupd10::conjure() },
                        pupd11: unsafe { Pupd11::conjure() },
                        pupd12: unsafe { Pupd12::conjure() },
                        pupd13: unsafe { Pupd13::conjure() },
                        pupd14: unsafe { Pupd14::conjure() },
                        pupd15: unsafe { Pupd15::conjure() },
                    }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn transition<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >(
                    self,
                ) -> Register<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >
                where
                    NewPupd0: pupd0::State,
                    NewPupd1: pupd1::State,
                    NewPupd2: pupd2::State,
                    NewPupd3: pupd3::State,
                    NewPupd4: pupd4::State,
                    NewPupd5: pupd5::State,
                    NewPupd6: pupd6::State,
                    NewPupd7: pupd7::State,
                    NewPupd8: pupd8::State,
                    NewPupd9: pupd9::State,
                    NewPupd10: pupd10::State,
                    NewPupd11: pupd11::State,
                    NewPupd12: pupd12::State,
                    NewPupd13: pupd13::State,
                    NewPupd14: pupd14::State,
                    NewPupd15: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd1<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    S,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd2<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    S,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd3<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    S,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd4<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    S,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd5<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    S,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd6<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    S,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd7<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    S,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd8<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    S,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd9<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    S,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd10<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    S,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd11<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    S,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd12<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    S,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd13<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    S,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd14<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    S,
                    Pupd15,
                >
                where
                    S: pupd14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd15<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    S,
                >
                where
                    S: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub const BASE_ADDR: u32 = 1207960576u32;
        pub struct Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub moder: Moder,
            pub otyper: Otyper,
            pub ospeedr: Ospeedr,
            pub pupdr: Pupdr,
        }
        pub type Reset = Block<
            moder::Reset,
            otyper::Reset,
            ospeedr::Reset,
            pupdr::Reset,
        >;
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn moder<R>(
                self,
                f: impl FnOnce(Moder) -> R,
            ) -> Block<R, Otyper, Ospeedr, Pupdr> {
                Block {
                    moder: f(self.moder),
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn otyper<R>(
                self,
                f: impl FnOnce(Otyper) -> R,
            ) -> Block<Moder, R, Ospeedr, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: f(self.otyper),
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn ospeedr<R>(
                self,
                f: impl FnOnce(Ospeedr) -> R,
            ) -> Block<Moder, Otyper, R, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: f(self.ospeedr),
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn pupdr<R>(
                self,
                f: impl FnOnce(Pupdr) -> R,
            ) -> Block<Moder, Otyper, Ospeedr, R> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: f(self.pupdr),
                }
            }
        }
    }
    mod gpiog {
        pub mod moder {
            pub mod mode0 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode1 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode0::OFFSET + super::mode0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode0::OFFSET + super::mode0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode2 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode1::OFFSET + super::mode1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode1::OFFSET + super::mode1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode3 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode2::OFFSET + super::mode2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode2::OFFSET + super::mode2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode4 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode3::OFFSET + super::mode3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode3::OFFSET + super::mode3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode5 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode4::OFFSET + super::mode4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode4::OFFSET + super::mode4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode6 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode5::OFFSET + super::mode5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode5::OFFSET + super::mode5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode7 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode6::OFFSET + super::mode6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode6::OFFSET + super::mode6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode8 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode7::OFFSET + super::mode7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode7::OFFSET + super::mode7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode9 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode8::OFFSET + super::mode8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode8::OFFSET + super::mode8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode10 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode9::OFFSET + super::mode9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode9::OFFSET + super::mode9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode11 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode10::OFFSET + super::mode10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode10::OFFSET + super::mode10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode12 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode11::OFFSET + super::mode11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode11::OFFSET + super::mode11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode13 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode12::OFFSET + super::mode12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode12::OFFSET + super::mode12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode14 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode13::OFFSET + super::mode13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode13::OFFSET + super::mode13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod mode15 {
                pub struct Input {
                    sealed: (),
                }
                pub struct Output {
                    sealed: (),
                }
                pub struct Alternate {
                    sealed: (),
                }
                pub struct Analog {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::mode14::OFFSET + super::mode14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Analog;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Input,
                    Output,
                    Alternate,
                    Analog,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Input {
                    const RAW: States = States::Input;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Input as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Output {
                    const RAW: States = States::Output;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Input as u32) < (States::Output as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Output as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Alternate {
                    const RAW: States = States::Alternate;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Output as u32) < (States::Alternate as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Alternate as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Analog {
                    const RAW: States = States::Analog;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Alternate as u32) < (States::Analog as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Analog as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::mode14::OFFSET + super::mode14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with mode14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = 0 as u32;
            pub struct Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: Mode0,
                pub mode1: Mode1,
                pub mode2: Mode2,
                pub mode3: Mode3,
                pub mode4: Mode4,
                pub mode5: Mode5,
                pub mode6: Mode6,
                pub mode7: Mode7,
                pub mode8: Mode8,
                pub mode9: Mode9,
                pub mode10: Mode10,
                pub mode11: Mode11,
                pub mode12: Mode12,
                pub mode13: Mode13,
                pub mode14: Mode14,
                pub mode15: Mode15,
            }
            pub type Reset = Register<
                mode0::Reset,
                mode1::Reset,
                mode2::Reset,
                mode3::Reset,
                mode4::Reset,
                mode5::Reset,
                mode6::Reset,
                mode7::Reset,
                mode8::Reset,
                mode9::Reset,
                mode10::Reset,
                mode11::Reset,
                mode12::Reset,
                mode13::Reset,
                mode14::Reset,
                mode15::Reset,
            >;
            pub struct TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > {
                pub mode0: core::marker::PhantomData<Mode0>,
                pub mode1: core::marker::PhantomData<Mode1>,
                pub mode2: core::marker::PhantomData<Mode2>,
                pub mode3: core::marker::PhantomData<Mode3>,
                pub mode4: core::marker::PhantomData<Mode4>,
                pub mode5: core::marker::PhantomData<Mode5>,
                pub mode6: core::marker::PhantomData<Mode6>,
                pub mode7: core::marker::PhantomData<Mode7>,
                pub mode8: core::marker::PhantomData<Mode8>,
                pub mode9: core::marker::PhantomData<Mode9>,
                pub mode10: core::marker::PhantomData<Mode10>,
                pub mode11: core::marker::PhantomData<Mode11>,
                pub mode12: core::marker::PhantomData<Mode12>,
                pub mode13: core::marker::PhantomData<Mode13>,
                pub mode14: core::marker::PhantomData<Mode14>,
                pub mode15: core::marker::PhantomData<Mode15>,
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        mode0: core::marker::PhantomData,
                        mode1: core::marker::PhantomData,
                        mode2: core::marker::PhantomData,
                        mode3: core::marker::PhantomData,
                        mode4: core::marker::PhantomData,
                        mode5: core::marker::PhantomData,
                        mode6: core::marker::PhantomData,
                        mode7: core::marker::PhantomData,
                        mode8: core::marker::PhantomData,
                        mode9: core::marker::PhantomData,
                        mode10: core::marker::PhantomData,
                        mode11: core::marker::PhantomData,
                        mode12: core::marker::PhantomData,
                        mode13: core::marker::PhantomData,
                        mode14: core::marker::PhantomData,
                        mode15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    let reg_value = ((Mode0::RAW as u32) << mode0::OFFSET)
                        | ((Mode1::RAW as u32) << mode1::OFFSET)
                        | ((Mode2::RAW as u32) << mode2::OFFSET)
                        | ((Mode3::RAW as u32) << mode3::OFFSET)
                        | ((Mode4::RAW as u32) << mode4::OFFSET)
                        | ((Mode5::RAW as u32) << mode5::OFFSET)
                        | ((Mode6::RAW as u32) << mode6::OFFSET)
                        | ((Mode7::RAW as u32) << mode7::OFFSET)
                        | ((Mode8::RAW as u32) << mode8::OFFSET)
                        | ((Mode9::RAW as u32) << mode9::OFFSET)
                        | ((Mode10::RAW as u32) << mode10::OFFSET)
                        | ((Mode11::RAW as u32) << mode11::OFFSET)
                        | ((Mode12::RAW as u32) << mode12::OFFSET)
                        | ((Mode13::RAW as u32) << mode13::OFFSET)
                        | ((Mode14::RAW as u32) << mode14::OFFSET)
                        | ((Mode15::RAW as u32) << mode15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        mode0: unsafe { Mode0::conjure() },
                        mode1: unsafe { Mode1::conjure() },
                        mode2: unsafe { Mode2::conjure() },
                        mode3: unsafe { Mode3::conjure() },
                        mode4: unsafe { Mode4::conjure() },
                        mode5: unsafe { Mode5::conjure() },
                        mode6: unsafe { Mode6::conjure() },
                        mode7: unsafe { Mode7::conjure() },
                        mode8: unsafe { Mode8::conjure() },
                        mode9: unsafe { Mode9::conjure() },
                        mode10: unsafe { Mode10::conjure() },
                        mode11: unsafe { Mode11::conjure() },
                        mode12: unsafe { Mode12::conjure() },
                        mode13: unsafe { Mode13::conjure() },
                        mode14: unsafe { Mode14::conjure() },
                        mode15: unsafe { Mode15::conjure() },
                    }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > Register<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn transition<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >(
                    self,
                ) -> Register<
                    NewMode0,
                    NewMode1,
                    NewMode2,
                    NewMode3,
                    NewMode4,
                    NewMode5,
                    NewMode6,
                    NewMode7,
                    NewMode8,
                    NewMode9,
                    NewMode10,
                    NewMode11,
                    NewMode12,
                    NewMode13,
                    NewMode14,
                    NewMode15,
                >
                where
                    NewMode0: mode0::State,
                    NewMode1: mode1::State,
                    NewMode2: mode2::State,
                    NewMode3: mode3::State,
                    NewMode4: mode4::State,
                    NewMode5: mode5::State,
                    NewMode6: mode6::State,
                    NewMode7: mode7::State,
                    NewMode8: mode8::State,
                    NewMode9: mode9::State,
                    NewMode10: mode10::State,
                    NewMode11: mode11::State,
                    NewMode12: mode12::State,
                    NewMode13: mode13::State,
                    NewMode14: mode14::State,
                    NewMode15: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode1<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    S,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode2<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    S,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode3<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    S,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode4<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    S,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode5<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    S,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode6<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    S,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode7<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    S,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode8<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    S,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode9<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    S,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode10<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    S,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode11<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    S,
                    Mode12,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode12<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    S,
                    Mode13,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode13<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    S,
                    Mode14,
                    Mode15,
                >
                where
                    S: mode13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode14<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    S,
                    Mode15,
                >
                where
                    S: mode14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            > TransitionBuilder<
                Mode0,
                Mode1,
                Mode2,
                Mode3,
                Mode4,
                Mode5,
                Mode6,
                Mode7,
                Mode8,
                Mode9,
                Mode10,
                Mode11,
                Mode12,
                Mode13,
                Mode14,
                Mode15,
            >
            where
                Mode0: mode0::State,
                Mode1: mode1::State,
                Mode2: mode2::State,
                Mode3: mode3::State,
                Mode4: mode4::State,
                Mode5: mode5::State,
                Mode6: mode6::State,
                Mode7: mode7::State,
                Mode8: mode8::State,
                Mode9: mode9::State,
                Mode10: mode10::State,
                Mode11: mode11::State,
                Mode12: mode12::State,
                Mode13: mode13::State,
                Mode14: mode14::State,
                Mode15: mode15::State,
            {
                pub fn mode15<S>(
                    self,
                ) -> TransitionBuilder<
                    Mode0,
                    Mode1,
                    Mode2,
                    Mode3,
                    Mode4,
                    Mode5,
                    Mode6,
                    Mode7,
                    Mode8,
                    Mode9,
                    Mode10,
                    Mode11,
                    Mode12,
                    Mode13,
                    Mode14,
                    S,
                >
                where
                    S: mode15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod otyper {
            pub mod ot0 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot1 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot0::OFFSET + super::ot0::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot0::OFFSET + super::ot0::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot2 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot1::OFFSET + super::ot1::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot1::OFFSET + super::ot1::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot3 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot2::OFFSET + super::ot2::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot2::OFFSET + super::ot2::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot4 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot3::OFFSET + super::ot3::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot3::OFFSET + super::ot3::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot5 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot4::OFFSET + super::ot4::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot4::OFFSET + super::ot4::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot6 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot5::OFFSET + super::ot5::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot5::OFFSET + super::ot5::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot7 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot6::OFFSET + super::ot6::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot6::OFFSET + super::ot6::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot8 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot7::OFFSET + super::ot7::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot7::OFFSET + super::ot7::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot9 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot8::OFFSET + super::ot8::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot8::OFFSET + super::ot8::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot10 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot9::OFFSET + super::ot9::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot9::OFFSET + super::ot9::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot11 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot10::OFFSET + super::ot10::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot10::OFFSET + super::ot10::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot12 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot11::OFFSET + super::ot11::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot11::OFFSET + super::ot11::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot13 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot12::OFFSET + super::ot12::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot12::OFFSET + super::ot12::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot14 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot13::OFFSET + super::ot13::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot13::OFFSET + super::ot13::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ot15 {
                pub struct PushPull {
                    sealed: (),
                }
                pub struct OpenDrain {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ot14::OFFSET + super::ot14::WIDTH;
                pub const WIDTH: u8 = 1u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = PushPull;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    PushPull,
                    OpenDrain,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for PushPull {
                    const RAW: States = States::PushPull;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::PushPull as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                impl State for OpenDrain {
                    const RAW: States = States::OpenDrain;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PushPull as u32)
                    < (States::OpenDrain as u32))
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::OpenDrain as u32) >> 1u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 1",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ot14::OFFSET + super::ot14::WIDTH <= OFFSET) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ot14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::moder::OFFSET + 32 as u32;
            pub struct Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: Ot0,
                pub ot1: Ot1,
                pub ot2: Ot2,
                pub ot3: Ot3,
                pub ot4: Ot4,
                pub ot5: Ot5,
                pub ot6: Ot6,
                pub ot7: Ot7,
                pub ot8: Ot8,
                pub ot9: Ot9,
                pub ot10: Ot10,
                pub ot11: Ot11,
                pub ot12: Ot12,
                pub ot13: Ot13,
                pub ot14: Ot14,
                pub ot15: Ot15,
            }
            pub type Reset = Register<
                ot0::Reset,
                ot1::Reset,
                ot2::Reset,
                ot3::Reset,
                ot4::Reset,
                ot5::Reset,
                ot6::Reset,
                ot7::Reset,
                ot8::Reset,
                ot9::Reset,
                ot10::Reset,
                ot11::Reset,
                ot12::Reset,
                ot13::Reset,
                ot14::Reset,
                ot15::Reset,
            >;
            pub struct TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > {
                pub ot0: core::marker::PhantomData<Ot0>,
                pub ot1: core::marker::PhantomData<Ot1>,
                pub ot2: core::marker::PhantomData<Ot2>,
                pub ot3: core::marker::PhantomData<Ot3>,
                pub ot4: core::marker::PhantomData<Ot4>,
                pub ot5: core::marker::PhantomData<Ot5>,
                pub ot6: core::marker::PhantomData<Ot6>,
                pub ot7: core::marker::PhantomData<Ot7>,
                pub ot8: core::marker::PhantomData<Ot8>,
                pub ot9: core::marker::PhantomData<Ot9>,
                pub ot10: core::marker::PhantomData<Ot10>,
                pub ot11: core::marker::PhantomData<Ot11>,
                pub ot12: core::marker::PhantomData<Ot12>,
                pub ot13: core::marker::PhantomData<Ot13>,
                pub ot14: core::marker::PhantomData<Ot14>,
                pub ot15: core::marker::PhantomData<Ot15>,
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ot0: core::marker::PhantomData,
                        ot1: core::marker::PhantomData,
                        ot2: core::marker::PhantomData,
                        ot3: core::marker::PhantomData,
                        ot4: core::marker::PhantomData,
                        ot5: core::marker::PhantomData,
                        ot6: core::marker::PhantomData,
                        ot7: core::marker::PhantomData,
                        ot8: core::marker::PhantomData,
                        ot9: core::marker::PhantomData,
                        ot10: core::marker::PhantomData,
                        ot11: core::marker::PhantomData,
                        ot12: core::marker::PhantomData,
                        ot13: core::marker::PhantomData,
                        ot14: core::marker::PhantomData,
                        ot15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    let reg_value = ((Ot0::RAW as u32) << ot0::OFFSET)
                        | ((Ot1::RAW as u32) << ot1::OFFSET)
                        | ((Ot2::RAW as u32) << ot2::OFFSET)
                        | ((Ot3::RAW as u32) << ot3::OFFSET)
                        | ((Ot4::RAW as u32) << ot4::OFFSET)
                        | ((Ot5::RAW as u32) << ot5::OFFSET)
                        | ((Ot6::RAW as u32) << ot6::OFFSET)
                        | ((Ot7::RAW as u32) << ot7::OFFSET)
                        | ((Ot8::RAW as u32) << ot8::OFFSET)
                        | ((Ot9::RAW as u32) << ot9::OFFSET)
                        | ((Ot10::RAW as u32) << ot10::OFFSET)
                        | ((Ot11::RAW as u32) << ot11::OFFSET)
                        | ((Ot12::RAW as u32) << ot12::OFFSET)
                        | ((Ot13::RAW as u32) << ot13::OFFSET)
                        | ((Ot14::RAW as u32) << ot14::OFFSET)
                        | ((Ot15::RAW as u32) << ot15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ot0: unsafe { Ot0::conjure() },
                        ot1: unsafe { Ot1::conjure() },
                        ot2: unsafe { Ot2::conjure() },
                        ot3: unsafe { Ot3::conjure() },
                        ot4: unsafe { Ot4::conjure() },
                        ot5: unsafe { Ot5::conjure() },
                        ot6: unsafe { Ot6::conjure() },
                        ot7: unsafe { Ot7::conjure() },
                        ot8: unsafe { Ot8::conjure() },
                        ot9: unsafe { Ot9::conjure() },
                        ot10: unsafe { Ot10::conjure() },
                        ot11: unsafe { Ot11::conjure() },
                        ot12: unsafe { Ot12::conjure() },
                        ot13: unsafe { Ot13::conjure() },
                        ot14: unsafe { Ot14::conjure() },
                        ot15: unsafe { Ot15::conjure() },
                    }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > Register<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn transition<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >(
                    self,
                ) -> Register<
                    NewOt0,
                    NewOt1,
                    NewOt2,
                    NewOt3,
                    NewOt4,
                    NewOt5,
                    NewOt6,
                    NewOt7,
                    NewOt8,
                    NewOt9,
                    NewOt10,
                    NewOt11,
                    NewOt12,
                    NewOt13,
                    NewOt14,
                    NewOt15,
                >
                where
                    NewOt0: ot0::State,
                    NewOt1: ot1::State,
                    NewOt2: ot2::State,
                    NewOt3: ot3::State,
                    NewOt4: ot4::State,
                    NewOt5: ot5::State,
                    NewOt6: ot6::State,
                    NewOt7: ot7::State,
                    NewOt8: ot8::State,
                    NewOt9: ot9::State,
                    NewOt10: ot10::State,
                    NewOt11: ot11::State,
                    NewOt12: ot12::State,
                    NewOt13: ot13::State,
                    NewOt14: ot14::State,
                    NewOt15: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    S,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    S,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    S,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    S,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    S,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    S,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    S,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    S,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    S,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    S,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    S,
                    Ot12,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    S,
                    Ot13,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    S,
                    Ot14,
                    Ot15,
                >
                where
                    S: ot13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    S,
                    Ot15,
                >
                where
                    S: ot14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            > TransitionBuilder<
                Ot0,
                Ot1,
                Ot2,
                Ot3,
                Ot4,
                Ot5,
                Ot6,
                Ot7,
                Ot8,
                Ot9,
                Ot10,
                Ot11,
                Ot12,
                Ot13,
                Ot14,
                Ot15,
            >
            where
                Ot0: ot0::State,
                Ot1: ot1::State,
                Ot2: ot2::State,
                Ot3: ot3::State,
                Ot4: ot4::State,
                Ot5: ot5::State,
                Ot6: ot6::State,
                Ot7: ot7::State,
                Ot8: ot8::State,
                Ot9: ot9::State,
                Ot10: ot10::State,
                Ot11: ot11::State,
                Ot12: ot12::State,
                Ot13: ot13::State,
                Ot14: ot14::State,
                Ot15: ot15::State,
            {
                pub fn ot15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ot0,
                    Ot1,
                    Ot2,
                    Ot3,
                    Ot4,
                    Ot5,
                    Ot6,
                    Ot7,
                    Ot8,
                    Ot9,
                    Ot10,
                    Ot11,
                    Ot12,
                    Ot13,
                    Ot14,
                    S,
                >
                where
                    S: ot15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod ospeedr {
            pub mod ospeed0 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed1 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed0::OFFSET + super::ospeed0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed0::OFFSET + super::ospeed0::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed2 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed1::OFFSET + super::ospeed1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed1::OFFSET + super::ospeed1::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed3 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed2::OFFSET + super::ospeed2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed2::OFFSET + super::ospeed2::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed4 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed3::OFFSET + super::ospeed3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed3::OFFSET + super::ospeed3::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed5 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed4::OFFSET + super::ospeed4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed4::OFFSET + super::ospeed4::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed6 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed5::OFFSET + super::ospeed5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed5::OFFSET + super::ospeed5::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed7 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed6::OFFSET + super::ospeed6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed6::OFFSET + super::ospeed6::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed8 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed7::OFFSET + super::ospeed7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed7::OFFSET + super::ospeed7::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed9 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed8::OFFSET + super::ospeed8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed8::OFFSET + super::ospeed8::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed10 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed9::OFFSET + super::ospeed9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed9::OFFSET + super::ospeed9::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed11 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed10::OFFSET + super::ospeed10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed10::OFFSET + super::ospeed10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed12 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed11::OFFSET + super::ospeed11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed11::OFFSET + super::ospeed11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed13 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed12::OFFSET + super::ospeed12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed12::OFFSET + super::ospeed12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed14 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed13::OFFSET + super::ospeed13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed13::OFFSET + super::ospeed13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod ospeed15 {
                pub struct Low {
                    sealed: (),
                }
                pub struct Medium {
                    sealed: (),
                }
                pub struct High {
                    sealed: (),
                }
                pub struct VeryHigh {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::ospeed14::OFFSET + super::ospeed14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = Low;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    Low,
                    Medium,
                    High,
                    VeryHigh,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for Low {
                    const RAW: States = States::Low;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::Low as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for Medium {
                    const RAW: States = States::Medium;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Low as u32) < (States::Medium as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::Medium as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for High {
                    const RAW: States = States::High;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::Medium as u32) < (States::High as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::High as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for VeryHigh {
                    const RAW: States = States::VeryHigh;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::High as u32) < (States::VeryHigh as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::VeryHigh as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::ospeed14::OFFSET + super::ospeed14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with ospeed14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::otyper::OFFSET + 32 as u32;
            pub struct Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: Ospeed0,
                pub ospeed1: Ospeed1,
                pub ospeed2: Ospeed2,
                pub ospeed3: Ospeed3,
                pub ospeed4: Ospeed4,
                pub ospeed5: Ospeed5,
                pub ospeed6: Ospeed6,
                pub ospeed7: Ospeed7,
                pub ospeed8: Ospeed8,
                pub ospeed9: Ospeed9,
                pub ospeed10: Ospeed10,
                pub ospeed11: Ospeed11,
                pub ospeed12: Ospeed12,
                pub ospeed13: Ospeed13,
                pub ospeed14: Ospeed14,
                pub ospeed15: Ospeed15,
            }
            pub type Reset = Register<
                ospeed0::Reset,
                ospeed1::Reset,
                ospeed2::Reset,
                ospeed3::Reset,
                ospeed4::Reset,
                ospeed5::Reset,
                ospeed6::Reset,
                ospeed7::Reset,
                ospeed8::Reset,
                ospeed9::Reset,
                ospeed10::Reset,
                ospeed11::Reset,
                ospeed12::Reset,
                ospeed13::Reset,
                ospeed14::Reset,
                ospeed15::Reset,
            >;
            pub struct TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > {
                pub ospeed0: core::marker::PhantomData<Ospeed0>,
                pub ospeed1: core::marker::PhantomData<Ospeed1>,
                pub ospeed2: core::marker::PhantomData<Ospeed2>,
                pub ospeed3: core::marker::PhantomData<Ospeed3>,
                pub ospeed4: core::marker::PhantomData<Ospeed4>,
                pub ospeed5: core::marker::PhantomData<Ospeed5>,
                pub ospeed6: core::marker::PhantomData<Ospeed6>,
                pub ospeed7: core::marker::PhantomData<Ospeed7>,
                pub ospeed8: core::marker::PhantomData<Ospeed8>,
                pub ospeed9: core::marker::PhantomData<Ospeed9>,
                pub ospeed10: core::marker::PhantomData<Ospeed10>,
                pub ospeed11: core::marker::PhantomData<Ospeed11>,
                pub ospeed12: core::marker::PhantomData<Ospeed12>,
                pub ospeed13: core::marker::PhantomData<Ospeed13>,
                pub ospeed14: core::marker::PhantomData<Ospeed14>,
                pub ospeed15: core::marker::PhantomData<Ospeed15>,
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        ospeed0: core::marker::PhantomData,
                        ospeed1: core::marker::PhantomData,
                        ospeed2: core::marker::PhantomData,
                        ospeed3: core::marker::PhantomData,
                        ospeed4: core::marker::PhantomData,
                        ospeed5: core::marker::PhantomData,
                        ospeed6: core::marker::PhantomData,
                        ospeed7: core::marker::PhantomData,
                        ospeed8: core::marker::PhantomData,
                        ospeed9: core::marker::PhantomData,
                        ospeed10: core::marker::PhantomData,
                        ospeed11: core::marker::PhantomData,
                        ospeed12: core::marker::PhantomData,
                        ospeed13: core::marker::PhantomData,
                        ospeed14: core::marker::PhantomData,
                        ospeed15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    let reg_value = ((Ospeed0::RAW as u32) << ospeed0::OFFSET)
                        | ((Ospeed1::RAW as u32) << ospeed1::OFFSET)
                        | ((Ospeed2::RAW as u32) << ospeed2::OFFSET)
                        | ((Ospeed3::RAW as u32) << ospeed3::OFFSET)
                        | ((Ospeed4::RAW as u32) << ospeed4::OFFSET)
                        | ((Ospeed5::RAW as u32) << ospeed5::OFFSET)
                        | ((Ospeed6::RAW as u32) << ospeed6::OFFSET)
                        | ((Ospeed7::RAW as u32) << ospeed7::OFFSET)
                        | ((Ospeed8::RAW as u32) << ospeed8::OFFSET)
                        | ((Ospeed9::RAW as u32) << ospeed9::OFFSET)
                        | ((Ospeed10::RAW as u32) << ospeed10::OFFSET)
                        | ((Ospeed11::RAW as u32) << ospeed11::OFFSET)
                        | ((Ospeed12::RAW as u32) << ospeed12::OFFSET)
                        | ((Ospeed13::RAW as u32) << ospeed13::OFFSET)
                        | ((Ospeed14::RAW as u32) << ospeed14::OFFSET)
                        | ((Ospeed15::RAW as u32) << ospeed15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        ospeed0: unsafe { Ospeed0::conjure() },
                        ospeed1: unsafe { Ospeed1::conjure() },
                        ospeed2: unsafe { Ospeed2::conjure() },
                        ospeed3: unsafe { Ospeed3::conjure() },
                        ospeed4: unsafe { Ospeed4::conjure() },
                        ospeed5: unsafe { Ospeed5::conjure() },
                        ospeed6: unsafe { Ospeed6::conjure() },
                        ospeed7: unsafe { Ospeed7::conjure() },
                        ospeed8: unsafe { Ospeed8::conjure() },
                        ospeed9: unsafe { Ospeed9::conjure() },
                        ospeed10: unsafe { Ospeed10::conjure() },
                        ospeed11: unsafe { Ospeed11::conjure() },
                        ospeed12: unsafe { Ospeed12::conjure() },
                        ospeed13: unsafe { Ospeed13::conjure() },
                        ospeed14: unsafe { Ospeed14::conjure() },
                        ospeed15: unsafe { Ospeed15::conjure() },
                    }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > Register<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn transition<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >(
                    self,
                ) -> Register<
                    NewOspeed0,
                    NewOspeed1,
                    NewOspeed2,
                    NewOspeed3,
                    NewOspeed4,
                    NewOspeed5,
                    NewOspeed6,
                    NewOspeed7,
                    NewOspeed8,
                    NewOspeed9,
                    NewOspeed10,
                    NewOspeed11,
                    NewOspeed12,
                    NewOspeed13,
                    NewOspeed14,
                    NewOspeed15,
                >
                where
                    NewOspeed0: ospeed0::State,
                    NewOspeed1: ospeed1::State,
                    NewOspeed2: ospeed2::State,
                    NewOspeed3: ospeed3::State,
                    NewOspeed4: ospeed4::State,
                    NewOspeed5: ospeed5::State,
                    NewOspeed6: ospeed6::State,
                    NewOspeed7: ospeed7::State,
                    NewOspeed8: ospeed8::State,
                    NewOspeed9: ospeed9::State,
                    NewOspeed10: ospeed10::State,
                    NewOspeed11: ospeed11::State,
                    NewOspeed12: ospeed12::State,
                    NewOspeed13: ospeed13::State,
                    NewOspeed14: ospeed14::State,
                    NewOspeed15: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed1<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    S,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed2<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    S,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed3<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    S,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed4<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    S,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed5<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    S,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed6<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    S,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed7<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    S,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed8<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    S,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed9<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    S,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed10<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    S,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed11<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    S,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed12<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    S,
                    Ospeed13,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed13<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    S,
                    Ospeed14,
                    Ospeed15,
                >
                where
                    S: ospeed13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed14<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    S,
                    Ospeed15,
                >
                where
                    S: ospeed14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            > TransitionBuilder<
                Ospeed0,
                Ospeed1,
                Ospeed2,
                Ospeed3,
                Ospeed4,
                Ospeed5,
                Ospeed6,
                Ospeed7,
                Ospeed8,
                Ospeed9,
                Ospeed10,
                Ospeed11,
                Ospeed12,
                Ospeed13,
                Ospeed14,
                Ospeed15,
            >
            where
                Ospeed0: ospeed0::State,
                Ospeed1: ospeed1::State,
                Ospeed2: ospeed2::State,
                Ospeed3: ospeed3::State,
                Ospeed4: ospeed4::State,
                Ospeed5: ospeed5::State,
                Ospeed6: ospeed6::State,
                Ospeed7: ospeed7::State,
                Ospeed8: ospeed8::State,
                Ospeed9: ospeed9::State,
                Ospeed10: ospeed10::State,
                Ospeed11: ospeed11::State,
                Ospeed12: ospeed12::State,
                Ospeed13: ospeed13::State,
                Ospeed14: ospeed14::State,
                Ospeed15: ospeed15::State,
            {
                pub fn ospeed15<S>(
                    self,
                ) -> TransitionBuilder<
                    Ospeed0,
                    Ospeed1,
                    Ospeed2,
                    Ospeed3,
                    Ospeed4,
                    Ospeed5,
                    Ospeed6,
                    Ospeed7,
                    Ospeed8,
                    Ospeed9,
                    Ospeed10,
                    Ospeed11,
                    Ospeed12,
                    Ospeed13,
                    Ospeed14,
                    S,
                >
                where
                    S: ospeed15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub mod pupdr {
            pub mod pupd0 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = 0;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd1 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd0::OFFSET + super::pupd0::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd0::OFFSET + super::pupd0::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd0",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd2 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd1::OFFSET + super::pupd1::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd1::OFFSET + super::pupd1::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd1",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd3 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd2::OFFSET + super::pupd2::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd2::OFFSET + super::pupd2::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd2",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd4 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd3::OFFSET + super::pupd3::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd3::OFFSET + super::pupd3::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd3",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd5 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd4::OFFSET + super::pupd4::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd4::OFFSET + super::pupd4::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd4",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd6 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd5::OFFSET + super::pupd5::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd5::OFFSET + super::pupd5::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd5",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd7 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd6::OFFSET + super::pupd6::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd6::OFFSET + super::pupd6::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd6",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd8 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd7::OFFSET + super::pupd7::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd7::OFFSET + super::pupd7::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd7",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd9 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd8::OFFSET + super::pupd8::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd8::OFFSET + super::pupd8::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd8",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd10 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd9::OFFSET + super::pupd9::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd9::OFFSET + super::pupd9::WIDTH <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd9",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd11 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd10::OFFSET + super::pupd10::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd10::OFFSET + super::pupd10::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd10",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd12 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd11::OFFSET + super::pupd11::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd11::OFFSET + super::pupd11::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd11",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd13 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd12::OFFSET + super::pupd12::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd12::OFFSET + super::pupd12::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd12",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd14 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd13::OFFSET + super::pupd13::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd13::OFFSET + super::pupd13::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd13",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub mod pupd15 {
                pub struct None {
                    sealed: (),
                }
                pub struct PullUp {
                    sealed: (),
                }
                pub struct PullDown {
                    sealed: (),
                }
                pub const OFFSET: u8 = super::pupd14::OFFSET + super::pupd14::WIDTH;
                pub const WIDTH: u8 = 2u8;
                pub struct Any {
                    state: States,
                }
                pub type Reset = None;
                pub const RESET: u32 = Reset::RAW as u32;
                #[repr(u32)]
                pub enum States {
                    None,
                    PullUp,
                    PullDown,
                }
                pub trait State {
                    const RAW: States;
                    unsafe fn conjure() -> Self;
                }
                impl State for None {
                    const RAW: States = States::None;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !(((States::None as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullUp {
                    const RAW: States = States::PullUp;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::None as u32) < (States::PullUp as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullUp as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                impl State for PullDown {
                    const RAW: States = States::PullDown;
                    unsafe fn conjure() -> Self {
                        Self { sealed: () }
                    }
                }
                const _: () = if !((States::PullUp as u32) < (States::PullDown as u32)) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit values must be unique and in ascending order",
                            ),
                        );
                    }
                };
                const _: () = if !(((States::PullDown as u32) >> 2u8) == 0) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "state bit value is larger than the maximum value supported by a field of width 2",
                            ),
                        );
                    }
                };
                const _: () = if !(super::pupd14::OFFSET + super::pupd14::WIDTH
                    <= OFFSET)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domains must be in order and non-overlapping. overlaps with pupd14",
                            ),
                        );
                    }
                };
                const _: () = if !(OFFSET + WIDTH <= 32) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "field domain goes out of bounds of register domain",
                            ),
                        );
                    }
                };
            }
            pub const OFFSET: u32 = super::ospeedr::OFFSET + 32 as u32;
            pub struct Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: Pupd0,
                pub pupd1: Pupd1,
                pub pupd2: Pupd2,
                pub pupd3: Pupd3,
                pub pupd4: Pupd4,
                pub pupd5: Pupd5,
                pub pupd6: Pupd6,
                pub pupd7: Pupd7,
                pub pupd8: Pupd8,
                pub pupd9: Pupd9,
                pub pupd10: Pupd10,
                pub pupd11: Pupd11,
                pub pupd12: Pupd12,
                pub pupd13: Pupd13,
                pub pupd14: Pupd14,
                pub pupd15: Pupd15,
            }
            pub type Reset = Register<
                pupd0::Reset,
                pupd1::Reset,
                pupd2::Reset,
                pupd3::Reset,
                pupd4::Reset,
                pupd5::Reset,
                pupd6::Reset,
                pupd7::Reset,
                pupd8::Reset,
                pupd9::Reset,
                pupd10::Reset,
                pupd11::Reset,
                pupd12::Reset,
                pupd13::Reset,
                pupd14::Reset,
                pupd15::Reset,
            >;
            pub struct TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > {
                pub pupd0: core::marker::PhantomData<Pupd0>,
                pub pupd1: core::marker::PhantomData<Pupd1>,
                pub pupd2: core::marker::PhantomData<Pupd2>,
                pub pupd3: core::marker::PhantomData<Pupd3>,
                pub pupd4: core::marker::PhantomData<Pupd4>,
                pub pupd5: core::marker::PhantomData<Pupd5>,
                pub pupd6: core::marker::PhantomData<Pupd6>,
                pub pupd7: core::marker::PhantomData<Pupd7>,
                pub pupd8: core::marker::PhantomData<Pupd8>,
                pub pupd9: core::marker::PhantomData<Pupd9>,
                pub pupd10: core::marker::PhantomData<Pupd10>,
                pub pupd11: core::marker::PhantomData<Pupd11>,
                pub pupd12: core::marker::PhantomData<Pupd12>,
                pub pupd13: core::marker::PhantomData<Pupd13>,
                pub pupd14: core::marker::PhantomData<Pupd14>,
                pub pupd15: core::marker::PhantomData<Pupd15>,
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub unsafe fn conjure() -> Self {
                    Self {
                        pupd0: core::marker::PhantomData,
                        pupd1: core::marker::PhantomData,
                        pupd2: core::marker::PhantomData,
                        pupd3: core::marker::PhantomData,
                        pupd4: core::marker::PhantomData,
                        pupd5: core::marker::PhantomData,
                        pupd6: core::marker::PhantomData,
                        pupd7: core::marker::PhantomData,
                        pupd8: core::marker::PhantomData,
                        pupd9: core::marker::PhantomData,
                        pupd10: core::marker::PhantomData,
                        pupd11: core::marker::PhantomData,
                        pupd12: core::marker::PhantomData,
                        pupd13: core::marker::PhantomData,
                        pupd14: core::marker::PhantomData,
                        pupd15: core::marker::PhantomData,
                    }
                }
                pub fn finish(
                    self,
                ) -> Register<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    let reg_value = ((Pupd0::RAW as u32) << pupd0::OFFSET)
                        | ((Pupd1::RAW as u32) << pupd1::OFFSET)
                        | ((Pupd2::RAW as u32) << pupd2::OFFSET)
                        | ((Pupd3::RAW as u32) << pupd3::OFFSET)
                        | ((Pupd4::RAW as u32) << pupd4::OFFSET)
                        | ((Pupd5::RAW as u32) << pupd5::OFFSET)
                        | ((Pupd6::RAW as u32) << pupd6::OFFSET)
                        | ((Pupd7::RAW as u32) << pupd7::OFFSET)
                        | ((Pupd8::RAW as u32) << pupd8::OFFSET)
                        | ((Pupd9::RAW as u32) << pupd9::OFFSET)
                        | ((Pupd10::RAW as u32) << pupd10::OFFSET)
                        | ((Pupd11::RAW as u32) << pupd11::OFFSET)
                        | ((Pupd12::RAW as u32) << pupd12::OFFSET)
                        | ((Pupd13::RAW as u32) << pupd13::OFFSET)
                        | ((Pupd14::RAW as u32) << pupd14::OFFSET)
                        | ((Pupd15::RAW as u32) << pupd15::OFFSET);
                    unsafe {
                        core::ptr::write_volatile(
                            (super::BASE_ADDR + OFFSET) as *mut u32,
                            reg_value,
                        );
                    }
                    Register {
                        pupd0: unsafe { Pupd0::conjure() },
                        pupd1: unsafe { Pupd1::conjure() },
                        pupd2: unsafe { Pupd2::conjure() },
                        pupd3: unsafe { Pupd3::conjure() },
                        pupd4: unsafe { Pupd4::conjure() },
                        pupd5: unsafe { Pupd5::conjure() },
                        pupd6: unsafe { Pupd6::conjure() },
                        pupd7: unsafe { Pupd7::conjure() },
                        pupd8: unsafe { Pupd8::conjure() },
                        pupd9: unsafe { Pupd9::conjure() },
                        pupd10: unsafe { Pupd10::conjure() },
                        pupd11: unsafe { Pupd11::conjure() },
                        pupd12: unsafe { Pupd12::conjure() },
                        pupd13: unsafe { Pupd13::conjure() },
                        pupd14: unsafe { Pupd14::conjure() },
                        pupd15: unsafe { Pupd15::conjure() },
                    }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > Register<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn transition<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >(
                    self,
                ) -> Register<
                    NewPupd0,
                    NewPupd1,
                    NewPupd2,
                    NewPupd3,
                    NewPupd4,
                    NewPupd5,
                    NewPupd6,
                    NewPupd7,
                    NewPupd8,
                    NewPupd9,
                    NewPupd10,
                    NewPupd11,
                    NewPupd12,
                    NewPupd13,
                    NewPupd14,
                    NewPupd15,
                >
                where
                    NewPupd0: pupd0::State,
                    NewPupd1: pupd1::State,
                    NewPupd2: pupd2::State,
                    NewPupd3: pupd3::State,
                    NewPupd4: pupd4::State,
                    NewPupd5: pupd5::State,
                    NewPupd6: pupd6::State,
                    NewPupd7: pupd7::State,
                    NewPupd8: pupd8::State,
                    NewPupd9: pupd9::State,
                    NewPupd10: pupd10::State,
                    NewPupd11: pupd11::State,
                    NewPupd12: pupd12::State,
                    NewPupd13: pupd13::State,
                    NewPupd14: pupd14::State,
                    NewPupd15: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }.finish()
                }
                pub fn build_transition(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                > {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd0<S>(
                    self,
                ) -> TransitionBuilder<
                    S,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd0::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd1<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    S,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd1::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd2<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    S,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd2::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd3<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    S,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd3::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd4<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    S,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd4::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd5<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    S,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd5::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd6<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    S,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd6::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd7<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    S,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd7::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd8<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    S,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd8::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd9<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    S,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd9::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd10<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    S,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd10::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd11<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    S,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd11::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd12<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    S,
                    Pupd13,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd12::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd13<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    S,
                    Pupd14,
                    Pupd15,
                >
                where
                    S: pupd13::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd14<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    S,
                    Pupd15,
                >
                where
                    S: pupd14::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
            impl<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            > TransitionBuilder<
                Pupd0,
                Pupd1,
                Pupd2,
                Pupd3,
                Pupd4,
                Pupd5,
                Pupd6,
                Pupd7,
                Pupd8,
                Pupd9,
                Pupd10,
                Pupd11,
                Pupd12,
                Pupd13,
                Pupd14,
                Pupd15,
            >
            where
                Pupd0: pupd0::State,
                Pupd1: pupd1::State,
                Pupd2: pupd2::State,
                Pupd3: pupd3::State,
                Pupd4: pupd4::State,
                Pupd5: pupd5::State,
                Pupd6: pupd6::State,
                Pupd7: pupd7::State,
                Pupd8: pupd8::State,
                Pupd9: pupd9::State,
                Pupd10: pupd10::State,
                Pupd11: pupd11::State,
                Pupd12: pupd12::State,
                Pupd13: pupd13::State,
                Pupd14: pupd14::State,
                Pupd15: pupd15::State,
            {
                pub fn pupd15<S>(
                    self,
                ) -> TransitionBuilder<
                    Pupd0,
                    Pupd1,
                    Pupd2,
                    Pupd3,
                    Pupd4,
                    Pupd5,
                    Pupd6,
                    Pupd7,
                    Pupd8,
                    Pupd9,
                    Pupd10,
                    Pupd11,
                    Pupd12,
                    Pupd13,
                    Pupd14,
                    S,
                >
                where
                    S: pupd15::State,
                {
                    unsafe { TransitionBuilder::conjure() }
                }
            }
        }
        pub const BASE_ADDR: u32 = 1207960576u32;
        pub struct Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub moder: Moder,
            pub otyper: Otyper,
            pub ospeedr: Ospeedr,
            pub pupdr: Pupdr,
        }
        pub type Reset = Block<
            moder::Reset,
            otyper::Reset,
            ospeedr::Reset,
            pupdr::Reset,
        >;
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn moder<R>(
                self,
                f: impl FnOnce(Moder) -> R,
            ) -> Block<R, Otyper, Ospeedr, Pupdr> {
                Block {
                    moder: f(self.moder),
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn otyper<R>(
                self,
                f: impl FnOnce(Otyper) -> R,
            ) -> Block<Moder, R, Ospeedr, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: f(self.otyper),
                    ospeedr: self.ospeedr,
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn ospeedr<R>(
                self,
                f: impl FnOnce(Ospeedr) -> R,
            ) -> Block<Moder, Otyper, R, Pupdr> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: f(self.ospeedr),
                    pupdr: self.pupdr,
                }
            }
        }
        impl<Moder, Otyper, Ospeedr, Pupdr> Block<Moder, Otyper, Ospeedr, Pupdr> {
            pub fn pupdr<R>(
                self,
                f: impl FnOnce(Pupdr) -> R,
            ) -> Block<Moder, Otyper, Ospeedr, R> {
                Block {
                    moder: self.moder,
                    otyper: self.otyper,
                    ospeedr: self.ospeedr,
                    pupdr: f(self.pupdr),
                }
            }
        }
    }
}
